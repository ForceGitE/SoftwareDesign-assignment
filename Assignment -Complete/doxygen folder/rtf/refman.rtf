{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033
{\fonttbl {\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}
{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}
{\f3\froman\fcharset2\fprq2{\*\panose 05050102010706020507}Symbol;}
}
{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;}
{\stylesheet
{\widctlpar\adjustright \fs20\cgrid \snext0 Normal;}
{\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid \sbasedon0 \snext0 heading 1;}
{\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid \sbasedon0 \snext0 heading 2;}
{\s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid \sbasedon0 \snext0 heading 3;}
{\s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 4;}{\*\cs10 \additive Default Paragraph Font;}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 5;}{\*\cs10 \additive Default Paragraph Font;}
{\s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid \sbasedon0 \snext15 Title;}
{\s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid \sbasedon0 \snext16 Subtitle;}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid \sbasedon0 \snext17 BodyText;}
{\s18\widctlpar\fs22\cgrid \sbasedon0 \snext18 DenseText;}
{\s28\widctlpar\tqc\tx4320\tqr\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext28 header;}
{\s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid \sbasedon0 \snext29 footer;}
{\s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext30 GroupHeader;}
{\s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext41 Code Example 0;}
{\s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext42 Code Example 1;}
{\s42\li720\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext43 Code Example 2;}
{\s43\li1080\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext44 Code Example 3;}
{\s44\li1440\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext45 Code Example 4;}
{\s45\li1800\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext46 Code Example 5;}
{\s46\li2160\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext47 Code Example 6;}
{\s47\li2520\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext48 Code Example 7;}
{\s48\li2880\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 8;}
{\s49\li3240\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 9;}
{\s50\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext51 List Continue 0;}
{\s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext52 List Continue 1;}
{\s52\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext53 List Continue 2;}
{\s53\li1080\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext54 List Continue 3;}
{\s54\li1440\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext55 List Continue 4;}
{\s55\li1800\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext56 List Continue 5;}
{\s56\li2160\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext57 List Continue 6;}
{\s57\li2520\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext58 List Continue 7;}
{\s58\li2880\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext59 List Continue 8;}
{\s59\li3240\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext59 List Continue 9;}
{\s60\li0\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext61 DescContinue 0;}
{\s61\li360\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext62 DescContinue 1;}
{\s62\li720\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext63 DescContinue 2;}
{\s63\li1080\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext64 DescContinue 3;}
{\s64\li1440\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext65 DescContinue 4;}
{\s65\li1800\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext66 DescContinue 5;}
{\s66\li2160\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext67 DescContinue 6;}
{\s67\li2520\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext68 DescContinue 7;}
{\s68\li2880\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext69 DescContinue 8;}
{\s69\li3240\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext69 DescContinue 9;}
{\s70\li0\sa30\sb30\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext81 LatexTOC 0;}
{\s71\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext82 LatexTOC 1;}
{\s72\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext83 LatexTOC 2;}
{\s73\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext84 LatexTOC 3;}
{\s74\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext85 LatexTOC 4;}
{\s75\li1800\sa15\sb15\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext86 LatexTOC 5;}
{\s76\li2160\sa12\sb12\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext87 LatexTOC 6;}
{\s77\li2520\sa9\sb9\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext88 LatexTOC 7;}
{\s78\li2880\sa6\sb6\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext89 LatexTOC 8;}
{\s79\li3240\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext89 LatexTOC 9;}
{\s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext81 \sautoupd List Bullet 0;}
{\s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid \sbasedon0 \snext82 \sautoupd List Bullet 1;}
{\s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid \sbasedon0 \snext83 \sautoupd List Bullet 2;}
{\s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid \sbasedon0 \snext84 \sautoupd List Bullet 3;}
{\s84\fi-360\li1800\widctlpar\jclisttab\tx1800{\*\pn \pnlvlbody\ilvl0\ls5\pnrnot0\pndec }\ls5\adjustright \fs20\cgrid \sbasedon0 \snext85 \sautoupd List Bullet 4;}
{\s85\fi-360\li2160\widctlpar\jclisttab\tx2160{\*\pn \pnlvlbody\ilvl0\ls6\pnrnot0\pndec }\ls6\adjustright \fs20\cgrid \sbasedon0 \snext86 \sautoupd List Bullet 5;}
{\s86\fi-360\li2520\widctlpar\jclisttab\tx2520{\*\pn \pnlvlbody\ilvl0\ls7\pnrnot0\pndec }\ls7\adjustright \fs20\cgrid \sbasedon0 \snext87 \sautoupd List Bullet 6;}
{\s87\fi-360\li2880\widctlpar\jclisttab\tx2880{\*\pn \pnlvlbody\ilvl0\ls8\pnrnot0\pndec }\ls8\adjustright \fs20\cgrid \sbasedon0 \snext88 \sautoupd List Bullet 7;}
{\s88\fi-360\li3240\widctlpar\jclisttab\tx3240{\*\pn \pnlvlbody\ilvl0\ls9\pnrnot0\pndec }\ls9\adjustright \fs20\cgrid \sbasedon0 \snext89 \sautoupd List Bullet 8;}
{\s89\fi-360\li3600\widctlpar\jclisttab\tx3600{\*\pn \pnlvlbody\ilvl0\ls10\pnrnot0\pndec }\ls10\adjustright \fs20\cgrid \sbasedon0 \snext89 \sautoupd List Bullet 9;}
{\s90\fi-360\li360\widctlpar\fs20\cgrid \sbasedon0 \snext91 \sautoupd List Enum 0;}
{\s91\fi-360\li720\widctlpar\fs20\cgrid \sbasedon0 \snext92 \sautoupd List Enum 1;}
{\s92\fi-360\li1080\widctlpar\fs20\cgrid \sbasedon0 \snext93 \sautoupd List Enum 2;}
{\s93\fi-360\li1440\widctlpar\fs20\cgrid \sbasedon0 \snext94 \sautoupd List Enum 3;}
{\s94\fi-360\li1800\widctlpar\fs20\cgrid \sbasedon0 \snext95 \sautoupd List Enum 4;}
{\s95\fi-360\li2160\widctlpar\fs20\cgrid \sbasedon0 \snext96 \sautoupd List Enum 5;}
{\s96\fi-360\li2520\widctlpar\fs20\cgrid \sbasedon0 \snext96 \sautoupd List Enum 5;}
{\s97\fi-360\li2880\widctlpar\fs20\cgrid \sbasedon0 \snext98 \sautoupd List Enum 7;}
{\s98\fi-360\li3240\widctlpar\fs20\cgrid \sbasedon0 \snext99 \sautoupd List Enum 8;}
{\s99\fi-360\li3600\widctlpar\fs20\cgrid \sbasedon0 \snext99 \sautoupd List Enum 9;}
}
{\comment begin body}
{\info 
{\title {\comment My Project }My Project}
{\comment Generated byDoxgyen. }
{\creatim \yr2016\mo12\dy15\hr12\min12\sec55}
}\pard\plain 
\sectd\pgnlcrm
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\vertalc\qc\par\par\par\par\par\par\par
\pard\plain \s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid 
{\field\fldedit {\*\fldinst TITLE \\*MERGEFORMAT}{\fldrslt TITLE}}\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\par
\par\par\par\par\par\par\par\par\par\par\par\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
{\field\fldedit {\*\fldinst AUTHOR \\*MERGEFORMAT}{\fldrslt AUTHOR}}\par
Version \par{\field\fldedit {\*\fldinst CREATEDATE \\*MERGEFORMAT}{\fldrslt CREATEDATE}}\par
\page\page\vertalt
\pard\plain 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Table of Contents\par
\pard\plain \par
{\field\fldedit {\*\fldinst TOC \\f \\*MERGEFORMAT}{\fldrslt Table of contents}}\par
\pard\plain 
\sect \sbkpage \pgndec \pgnrestart
\sect \sectd \sbknone
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Hierarchical Index\par \pard\plain 
{\tc \v Hierarchical Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Class Hierarchy\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This inheritance list is sorted roughly, but not completely, alphabetically:}
{
\par
\pard\plain \s71\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
Admin\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
tinyxml2::DynArray< T, INITIAL_SIZE >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
tinyxml2::DynArray< Block *, 10 >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
tinyxml2::DynArray< char, 20 >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
tinyxml2::DynArray< const char *, 10 >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
tinyxml2::Entity\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
LogIn\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
tinyxml2::LongFitsIntoSizeTMinusOne< bool >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
tinyxml2::LongFitsIntoSizeTMinusOne< false >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
tinyxml2::MemPool\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACG \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s72\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
tinyxml2::MemPoolT< sizeof(tinyxml2::XMLAttribute) >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
tinyxml2::MemPoolT< sizeof(tinyxml2::XMLComment) >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
tinyxml2::MemPoolT< sizeof(tinyxml2::XMLElement) >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
tinyxml2::MemPoolT< sizeof(tinyxml2::XMLText) >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
tinyxml2::MemPoolT< ITEM_SIZE >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
Quiz\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Report\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
tinyxml2::StrPair\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Student\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
tinyxml2::XMLAttribute\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
tinyxml2::XMLConstHandle\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAER \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
tinyxml2::XMLHandle\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
tinyxml2::XMLNode\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKD \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s72\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
tinyxml2::XMLComment\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
tinyxml2::XMLDeclaration\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
tinyxml2::XMLDocument\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
tinyxml2::XMLElement\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
tinyxml2::XMLText\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAANZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
tinyxml2::XMLUnknown\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
tinyxml2::XMLUtil\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAON \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
tinyxml2::XMLVisitor\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAPK \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s72\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
tinyxml2::XMLPrinter\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Class Index\par \pard\plain 
{\tc \v Class Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Class List\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here are the classes, structs, unions and interfaces with brief descriptions:}
{
\par
\pard\plain \s71\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b {\b Admin} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b tinyxml2::DynArray< T, INITIAL_SIZE >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b tinyxml2::Entity} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b LogIn} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b tinyxml2::LongFitsIntoSizeTMinusOne< bool >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b tinyxml2::LongFitsIntoSizeTMinusOne< false >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b tinyxml2::MemPool} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b tinyxml2::MemPoolT< ITEM_SIZE >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Quiz} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Report} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b tinyxml2::StrPair} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Student} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b tinyxml2::XMLAttribute} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b tinyxml2::XMLComment} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b tinyxml2::XMLConstHandle} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAER \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b tinyxml2::XMLDeclaration} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b tinyxml2::XMLDocument} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b tinyxml2::XMLElement} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b tinyxml2::XMLHandle} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b tinyxml2::XMLNode} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b tinyxml2::XMLPrinter} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b tinyxml2::XMLText} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAANZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b tinyxml2::XMLUnknown} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b tinyxml2::XMLUtil} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAON \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b tinyxml2::XMLVisitor} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAPK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Class Documentation{\tc \v Class Documentation}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Admin Class Reference\par \pard\plain 
{\tc\tcl2 \v Admin}
{\xe \v Admin}
{\bkmkstart AAAAAAAAAA}
{\bkmkend AAAAAAAAAA}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
main.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
tinyxml2::DynArray< T, INITIAL_SIZE > Class Template Reference\par \pard\plain 
{\tc\tcl2 \v tinyxml2::DynArray< T, INITIAL_SIZE >}
{\xe \v tinyxml2::DynArray< T, INITIAL_SIZE >}
{\bkmkstart AAAAAAAABK}
{\bkmkend AAAAAAAABK}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b Clear} (){\bkmkstart AAAAAAAABL}
{\bkmkend AAAAAAAABL}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b Push} (T t){\bkmkstart AAAAAAAABM}
{\bkmkend AAAAAAAABM}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

T * {\b PushArr} (int count){\bkmkstart AAAAAAAABN}
{\bkmkend AAAAAAAABN}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

T {\b Pop} (){\bkmkstart AAAAAAAABO}
{\bkmkend AAAAAAAABO}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b PopArr} (int count){\bkmkstart AAAAAAAABP}
{\bkmkend AAAAAAAABP}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b Empty} () const {\bkmkstart AAAAAAAABQ}
{\bkmkend AAAAAAAABQ}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

T & {\b operator[]} (int i){\bkmkstart AAAAAAAABR}
{\bkmkend AAAAAAAABR}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const T & {\b operator[]} (int i) const {\bkmkstart AAAAAAAABS}
{\bkmkend AAAAAAAABS}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const T & {\b PeekTop} () const {\bkmkstart AAAAAAAABT}
{\bkmkend AAAAAAAABT}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int {\b Size} () const {\bkmkstart AAAAAAAABU}
{\bkmkend AAAAAAAABU}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int {\b Capacity} () const {\bkmkstart AAAAAAAABV}
{\bkmkend AAAAAAAABV}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const T * {\b Mem} () const {\bkmkstart AAAAAAAABW}
{\bkmkend AAAAAAAABW}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

T * {\b Mem} (){\bkmkstart AAAAAAAABX}
{\bkmkend AAAAAAAABX}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
tinyxml2.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
tinyxml2::Entity Struct Reference\par \pard\plain 
{\tc\tcl2 \v tinyxml2::Entity}
{\xe \v tinyxml2::Entity}
{\bkmkstart AAAAAAAABY}
{\bkmkend AAAAAAAABY}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const char * {\b pattern}{\bkmkstart AAAAAAAABZ}
{\bkmkend AAAAAAAABZ}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int {\b length}{\bkmkstart AAAAAAAACA}
{\bkmkend AAAAAAAACA}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

char {\b value}{\bkmkstart AAAAAAAACB}
{\bkmkend AAAAAAAACB}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
tinyxml2.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
LogIn Class Reference\par \pard\plain 
{\tc\tcl2 \v LogIn}
{\xe \v LogIn}
{\bkmkstart AAAAAAAAAB}
{\bkmkend AAAAAAAAAB}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b LogIn} (string logname, string password){\bkmkstart AAAAAAAAAC}
{\bkmkend AAAAAAAAAC}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b checkLog} (){\bkmkstart AAAAAAAAAD}
{\bkmkend AAAAAAAAAD}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b checkName} (string name){\bkmkstart AAAAAAAAAE}
{\bkmkend AAAAAAAAAE}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b checkPass} (string pass){\bkmkstart AAAAAAAAAF}
{\bkmkend AAAAAAAAAF}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

string {\b getName} (){\bkmkstart AAAAAAAAAG}
{\bkmkend AAAAAAAAAG}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b checkAdmin} (){\bkmkstart AAAAAAAAAH}
{\bkmkend AAAAAAAAAH}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

string {\b name}{\bkmkstart AAAAAAAAAI}
{\bkmkend AAAAAAAAAI}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

string {\b pass}{\bkmkstart AAAAAAAAAJ}
{\bkmkend AAAAAAAAAJ}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

string {\b studentname}{\bkmkstart AAAAAAAAAK}
{\bkmkend AAAAAAAAAK}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
main.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
tinyxml2::LongFitsIntoSizeTMinusOne< bool > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v tinyxml2::LongFitsIntoSizeTMinusOne< bool >}
{\xe \v tinyxml2::LongFitsIntoSizeTMinusOne< bool >}
{\bkmkstart AAAAAAAACC}
{\bkmkend AAAAAAAACC}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b Fits} (unsigned long value){\bkmkstart AAAAAAAACD}
{\bkmkend AAAAAAAACD}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
tinyxml2.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
tinyxml2::LongFitsIntoSizeTMinusOne< false > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v tinyxml2::LongFitsIntoSizeTMinusOne< false >}
{\xe \v tinyxml2::LongFitsIntoSizeTMinusOne< false >}
{\bkmkstart AAAAAAAACE}
{\bkmkend AAAAAAAACE}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b Fits} (unsigned long){\bkmkstart AAAAAAAACF}
{\bkmkend AAAAAAAACF}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
tinyxml2.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
tinyxml2::MemPool Class Reference\par \pard\plain 
{\tc\tcl2 \v tinyxml2::MemPool}
{\xe \v tinyxml2::MemPool}
{\bkmkstart AAAAAAAACG}
{\bkmkend AAAAAAAACG}
Inheritance diagram for tinyxml2::MemPool:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classtinyxml2_1_1_mem_pool.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual int {\b ItemSize} () const  =0{\bkmkstart AAAAAAAACH}
{\bkmkend AAAAAAAACH}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void * {\b Alloc} ()=0{\bkmkstart AAAAAAAACI}
{\bkmkend AAAAAAAACI}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b Free} (void *)=0{\bkmkstart AAAAAAAACJ}
{\bkmkend AAAAAAAACJ}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b SetTracked} ()=0{\bkmkstart AAAAAAAACK}
{\bkmkend AAAAAAAACK}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b Clear} ()=0{\bkmkstart AAAAAAAACL}
{\bkmkend AAAAAAAACL}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
tinyxml2.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
tinyxml2::MemPoolT< ITEM_SIZE > Class Template Reference\par \pard\plain 
{\tc\tcl2 \v tinyxml2::MemPoolT< ITEM_SIZE >}
{\xe \v tinyxml2::MemPoolT< ITEM_SIZE >}
{\bkmkstart AAAAAAAACM}
{\bkmkend AAAAAAAACM}
Inheritance diagram for tinyxml2::MemPoolT< ITEM_SIZE >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classtinyxml2_1_1_mem_pool_t.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum \{ {\b ITEMS_PER_BLOCK} = (4 * 1024) / ITEM_SIZE
 \}{\bkmkstart AAAAAAAACN}
{\bkmkend AAAAAAAACN}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b Clear} (){\bkmkstart AAAAAAAACO}
{\bkmkend AAAAAAAACO}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual int {\b ItemSize} () const {\bkmkstart AAAAAAAACP}
{\bkmkend AAAAAAAACP}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int {\b CurrentAllocs} () const {\bkmkstart AAAAAAAACQ}
{\bkmkend AAAAAAAACQ}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void * {\b Alloc} (){\bkmkstart AAAAAAAACR}
{\bkmkend AAAAAAAACR}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b Free} (void *mem){\bkmkstart AAAAAAAACS}
{\bkmkend AAAAAAAACS}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b Trace} (const char *name){\bkmkstart AAAAAAAACT}
{\bkmkend AAAAAAAACT}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b SetTracked} (){\bkmkstart AAAAAAAACU}
{\bkmkend AAAAAAAACU}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int {\b Untracked} () const {\bkmkstart AAAAAAAACV}
{\bkmkend AAAAAAAACV}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
tinyxml2.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Quiz Class Reference\par \pard\plain 
{\tc\tcl2 \v Quiz}
{\xe \v Quiz}
{\bkmkstart AAAAAAAAAL}
{\bkmkend AAAAAAAAAL}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b Quiz} ({\b Student} studentquiz){\bkmkstart AAAAAAAAAM}
{\bkmkend AAAAAAAAAM}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b beginParsing} (){\bkmkstart AAAAAAAAAN}
{\bkmkend AAAAAAAAAN}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b askQuestion} (){\bkmkstart AAAAAAAAAO}
{\bkmkend AAAAAAAAAO}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b typeAnswer} (int answer){\bkmkstart AAAAAAAAAP}
{\bkmkend AAAAAAAAAP}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b Student} {\b getStudentObj} (){\bkmkstart AAAAAAAAAQ}
{\bkmkend AAAAAAAAAQ}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

vector< string > {\b mQuestionList}{\bkmkstart AAAAAAAAAR}
{\bkmkend AAAAAAAAAR}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

vector< int > {\b mAnswerList}{\bkmkstart AAAAAAAAAS}
{\bkmkend AAAAAAAAAS}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b Student} {\b studentattempt}{\bkmkstart AAAAAAAAAT}
{\bkmkend AAAAAAAAAT}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
main.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Report Class Reference\par \pard\plain 
{\tc\tcl2 \v Report}
{\xe \v Report}
{\bkmkstart AAAAAAAAAU}
{\bkmkend AAAAAAAAAU}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b Report} ({\b Student} Obj){\bkmkstart AAAAAAAAAV}
{\bkmkend AAAAAAAAAV}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b saveStudent} (){\bkmkstart AAAAAAAAAW}
{\bkmkend AAAAAAAAAW}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b saveOverall} (){\bkmkstart AAAAAAAAAX}
{\bkmkend AAAAAAAAAX}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b getReport} (){\bkmkstart AAAAAAAAAY}
{\bkmkend AAAAAAAAAY}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

string {\b name}{\bkmkstart AAAAAAAAAZ}
{\bkmkend AAAAAAAAAZ}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

string {\b Admin}{\bkmkstart AAAAAAAABA}
{\bkmkend AAAAAAAABA}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

string {\b results}{\bkmkstart AAAAAAAABB}
{\bkmkend AAAAAAAABB}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int {\b score}{\bkmkstart AAAAAAAABC}
{\bkmkend AAAAAAAABC}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
main.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
tinyxml2::StrPair Class Reference\par \pard\plain 
{\tc\tcl2 \v tinyxml2::StrPair}
{\xe \v tinyxml2::StrPair}
{\bkmkstart AAAAAAAACW}
{\bkmkend AAAAAAAACW}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum \{ {\b NEEDS_ENTITY_PROCESSING} = 0x01, 
{\b NEEDS_NEWLINE_NORMALIZATION} = 0x02, 
{\b NEEDS_WHITESPACE_COLLAPSING} = 0x04, 
{\b TEXT_ELEMENT} = NEEDS_ENTITY_PROCESSING | NEEDS_NEWLINE_NORMALIZATION, 
{\b TEXT_ELEMENT_LEAVE_ENTITIES} = NEEDS_NEWLINE_NORMALIZATION, 
{\b ATTRIBUTE_NAME} = 0, 
{\b ATTRIBUTE_VALUE} = NEEDS_ENTITY_PROCESSING | NEEDS_NEWLINE_NORMALIZATION, 
{\b ATTRIBUTE_VALUE_LEAVE_ENTITIES} = NEEDS_NEWLINE_NORMALIZATION, 
{\b COMMENT} = NEEDS_NEWLINE_NORMALIZATION
 \}{\bkmkstart AAAAAAAACX}
{\bkmkend AAAAAAAACX}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b Set} (char *start, char *end, int flags){\bkmkstart AAAAAAAACY}
{\bkmkend AAAAAAAACY}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const char * {\b GetStr} (){\bkmkstart AAAAAAAACZ}
{\bkmkend AAAAAAAACZ}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b Empty} () const {\bkmkstart AAAAAAAADA}
{\bkmkend AAAAAAAADA}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b SetInternedStr} (const char *str){\bkmkstart AAAAAAAADB}
{\bkmkend AAAAAAAADB}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b SetStr} (const char *str, int flags=0){\bkmkstart AAAAAAAADC}
{\bkmkend AAAAAAAADC}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

char * {\b ParseText} (char *in, const char *endTag, int strFlags){\bkmkstart AAAAAAAADD}
{\bkmkend AAAAAAAADD}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

char * {\b ParseName} (char *in){\bkmkstart AAAAAAAADE}
{\bkmkend AAAAAAAADE}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b TransferTo} ({\b StrPair} *other){\bkmkstart AAAAAAAADF}
{\bkmkend AAAAAAAADF}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b Reset} (){\bkmkstart AAAAAAAADG}
{\bkmkend AAAAAAAADG}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
tinyxml2.h\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
tinyxml2.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Student Class Reference\par \pard\plain 
{\tc\tcl2 \v Student}
{\xe \v Student}
{\bkmkstart AAAAAAAABD}
{\bkmkend AAAAAAAABD}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b Student} ({\b LogIn} logname){\bkmkstart AAAAAAAABE}
{\bkmkend AAAAAAAABE}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

string {\b getName} (){\bkmkstart AAAAAAAABF}
{\bkmkend AAAAAAAABF}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b updateScore} (){\bkmkstart AAAAAAAABG}
{\bkmkend AAAAAAAABG}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b updateAttempt} (){\bkmkstart AAAAAAAABH}
{\bkmkend AAAAAAAABH}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int {\b getScore} (){\bkmkstart AAAAAAAABI}
{\bkmkend AAAAAAAABI}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int {\b getAttempt} (){\bkmkstart AAAAAAAABJ}
{\bkmkend AAAAAAAABJ}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
main.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
tinyxml2::XMLAttribute Class Reference\par \pard\plain 
{\tc\tcl2 \v tinyxml2::XMLAttribute}
{\xe \v tinyxml2::XMLAttribute}
{\bkmkstart AAAAAAAADH}
{\bkmkend AAAAAAAADH}
\par
{
{\f2 #include <tinyxml2.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const char * {\b Name} () const {\bkmkstart AAAAAAAADI}
{\bkmkend AAAAAAAADI}
\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The name of the attribute. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const char * {\b Value} () const {\bkmkstart AAAAAAAADJ}
{\bkmkend AAAAAAAADJ}
\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The value of the attribute. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b XMLAttribute} * {\b Next} () const {\bkmkstart AAAAAAAADK}
{\bkmkend AAAAAAAADK}
\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The next attribute in the list. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b IntValue} () const \par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int64_t {\b Int64Value} () const {\bkmkstart AAAAAAAADL}
{\bkmkend AAAAAAAADL}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

unsigned {\b UnsignedValue} () const {\bkmkstart AAAAAAAADM}
{\bkmkend AAAAAAAADM}
\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Query as an unsigned integer. See {\b IntValue()} }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b BoolValue} () const {\bkmkstart AAAAAAAADN}
{\bkmkend AAAAAAAADN}
\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Query as a boolean. See {\b IntValue()} }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

double {\b DoubleValue} () const {\bkmkstart AAAAAAAADO}
{\bkmkend AAAAAAAADO}
\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Query as a double. See {\b IntValue()} }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

float {\b FloatValue} () const {\bkmkstart AAAAAAAADP}
{\bkmkend AAAAAAAADP}
\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Query as a float. See {\b IntValue()} }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
XMLError {\b QueryIntValue} (int *value) const \par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

XMLError {\b QueryUnsignedValue} (unsigned int *value) const {\bkmkstart AAAAAAAADQ}
{\bkmkend AAAAAAAADQ}
\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
See QueryIntValue. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

XMLError {\b QueryInt64Value} (int64_t *value) const {\bkmkstart AAAAAAAADR}
{\bkmkend AAAAAAAADR}
\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
See QueryIntValue. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

XMLError {\b QueryBoolValue} (bool *value) const {\bkmkstart AAAAAAAADS}
{\bkmkend AAAAAAAADS}
\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
See QueryIntValue. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

XMLError {\b QueryDoubleValue} (double *value) const {\bkmkstart AAAAAAAADT}
{\bkmkend AAAAAAAADT}
\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
See QueryIntValue. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

XMLError {\b QueryFloatValue} (float *value) const {\bkmkstart AAAAAAAADU}
{\bkmkend AAAAAAAADU}
\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
See QueryIntValue. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b SetAttribute} (const char *value){\bkmkstart AAAAAAAADV}
{\bkmkend AAAAAAAADV}
\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set the attribute to a string value. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b SetAttribute} (int value){\bkmkstart AAAAAAAADW}
{\bkmkend AAAAAAAADW}
\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set the attribute to value. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b SetAttribute} (unsigned value){\bkmkstart AAAAAAAADX}
{\bkmkend AAAAAAAADX}
\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set the attribute to value. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b SetAttribute} (int64_t value){\bkmkstart AAAAAAAADY}
{\bkmkend AAAAAAAADY}
\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set the attribute to value. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b SetAttribute} (bool value){\bkmkstart AAAAAAAADZ}
{\bkmkend AAAAAAAADZ}
\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set the attribute to value. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b SetAttribute} (double value){\bkmkstart AAAAAAAAEA}
{\bkmkend AAAAAAAAEA}
\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set the attribute to value. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b SetAttribute} (float value){\bkmkstart AAAAAAAAEB}
{\bkmkend AAAAAAAAEB}
\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set the attribute to value. }{
}\par
}}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

class {\b XMLElement}{\bkmkstart AAAAAAAAEC}
{\bkmkend AAAAAAAAEC}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An attribute is a name-value pair. Elements have an arbitrary number of attributes, each with a unique name.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid The attributes are not XMLNodes. You may only query the {\b Next()} attribute in a list. \par
}}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v IntValue\:tinyxml2::XMLAttribute}
{\xe \v tinyxml2::XMLAttribute\:IntValue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int tinyxml2::XMLAttribute::IntValue () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAED}
{\bkmkend AAAAAAAAED}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
IntValue interprets the attribute as an integer, and returns the value. If the value isn't an integer, 0 will be returned. There is no error checking; use {\b QueryIntValue()} if you need error checking. \par
}}
{\xe \v QueryIntValue\:tinyxml2::XMLAttribute}
{\xe \v tinyxml2::XMLAttribute\:QueryIntValue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
XMLError tinyxml2::XMLAttribute::QueryIntValue (int *  {\i value}) const}}
\par
{\bkmkstart AAAAAAAAEE}
{\bkmkend AAAAAAAAEE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
QueryIntValue interprets the attribute as an integer, and returns the value in the provided parameter. The function will return XML_SUCCESS on success, and XML_WRONG_ATTRIBUTE_TYPE if the conversion is not successful. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
tinyxml2.h\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
tinyxml2.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
tinyxml2::XMLComment Class Reference\par \pard\plain 
{\tc\tcl2 \v tinyxml2::XMLComment}
{\xe \v tinyxml2::XMLComment}
{\bkmkstart AAAAAAAAEF}
{\bkmkend AAAAAAAAEF}
\par
{
{\f2 #include <tinyxml2.h>}}\par
Inheritance diagram for tinyxml2::XMLComment:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classtinyxml2_1_1_x_m_l_comment.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual {\b XMLComment} * {\b ToComment} (){\bkmkstart AAAAAAAAEG}
{\bkmkend AAAAAAAAEG}
\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Safely cast to a Comment, or null. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const {\b XMLComment} * {\b ToComment} () const {\bkmkstart AAAAAAAAEH}
{\bkmkend AAAAAAAAEH}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b Accept} ({\b XMLVisitor} *visitor) const \par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b XMLNode} * {\b ShallowClone} ({\b XMLDocument} *document) const \par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b ShallowEqual} (const {\b XMLNode} *compare) const \par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b XMLComment} ({\b XMLDocument} *doc){\bkmkstart AAAAAAAAEI}
{\bkmkend AAAAAAAAEI}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

char * {\b ParseDeep} (char *, {\b StrPair} *endTag){\bkmkstart AAAAAAAAEJ}
{\bkmkend AAAAAAAAEJ}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

class {\b XMLDocument}{\bkmkstart AAAAAAAAEK}
{\bkmkend AAAAAAAAEK}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An XML Comment. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v Accept\:tinyxml2::XMLComment}
{\xe \v tinyxml2::XMLComment\:Accept}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool tinyxml2::XMLComment::Accept ({\b XMLVisitor} *  {\i visitor}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAEL}
{\bkmkend AAAAAAAAEL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Accept a hierarchical visit of the nodes in the TinyXML-2 DOM. Every node in the XML tree will be conditionally visited and the host will be called back via the {\b XMLVisitor} interface.\par
This is essentially a SAX interface for TinyXML-2. (Note however it doesn't re-parse the XML for the callbacks, so the performance of TinyXML-2 is unchanged by using this interface versus any other.)\par
The interface has been based on ideas from:\par
{
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\f2 http://www.saxproject.org/}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\f2 http://c2.com/cgi/wiki?HierarchicalVisitorPattern}\par}
Which are both good references for "visiting".\par
An example of using {\b Accept()}: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid XMLPrinter printer;\par
tinyxmlDoc.Accept( &printer );\par
const char* xmlcstr = printer.CStr();\par
}
 \par
}{
Implements {\b tinyxml2::XMLNode} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEM \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v ShallowClone\:tinyxml2::XMLComment}
{\xe \v tinyxml2::XMLComment\:ShallowClone}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b XMLNode} * tinyxml2::XMLComment::ShallowClone ({\b XMLDocument} *  {\i document}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAEN}
{\bkmkend AAAAAAAAEN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Make a copy of this node, but not its children. You may pass in a Document pointer that will be the owner of the new Node. If the 'document' is null, then the node returned will be allocated from the current Document. (this->{\b GetDocument()})\par
Note: if called on a {\b XMLDocument}, this will return null. \par
}{
Implements {\b tinyxml2::XMLNode} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEO \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v ShallowEqual\:tinyxml2::XMLComment}
{\xe \v tinyxml2::XMLComment\:ShallowEqual}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool tinyxml2::XMLComment::ShallowEqual (const {\b XMLNode} *  {\i compare}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAEP}
{\bkmkend AAAAAAAAEP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Test if 2 nodes are the same, but don't test children. The 2 nodes do not need to be in the same Document.\par
Note: if called on a {\b XMLDocument}, this will return false. \par
}{
Implements {\b tinyxml2::XMLNode} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEQ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
tinyxml2.h\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
tinyxml2.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
tinyxml2::XMLConstHandle Class Reference\par \pard\plain 
{\tc\tcl2 \v tinyxml2::XMLConstHandle}
{\xe \v tinyxml2::XMLConstHandle}
{\bkmkstart AAAAAAAAER}
{\bkmkend AAAAAAAAER}
\par
{
{\f2 #include <tinyxml2.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b XMLConstHandle} (const {\b XMLNode} *node){\bkmkstart AAAAAAAAES}
{\bkmkend AAAAAAAAES}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b XMLConstHandle} (const {\b XMLNode} &node){\bkmkstart AAAAAAAAET}
{\bkmkend AAAAAAAAET}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b XMLConstHandle} (const {\b XMLConstHandle} &ref){\bkmkstart AAAAAAAAEU}
{\bkmkend AAAAAAAAEU}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b XMLConstHandle} & {\b operator=} (const {\b XMLConstHandle} &ref){\bkmkstart AAAAAAAAEV}
{\bkmkend AAAAAAAAEV}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b XMLConstHandle} {\b FirstChild} () const {\bkmkstart AAAAAAAAEW}
{\bkmkend AAAAAAAAEW}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b XMLConstHandle} {\b FirstChildElement} (const char *name=0) const {\bkmkstart AAAAAAAAEX}
{\bkmkend AAAAAAAAEX}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b XMLConstHandle} {\b LastChild} () const {\bkmkstart AAAAAAAAEY}
{\bkmkend AAAAAAAAEY}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b XMLConstHandle} {\b LastChildElement} (const char *name=0) const {\bkmkstart AAAAAAAAEZ}
{\bkmkend AAAAAAAAEZ}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b XMLConstHandle} {\b PreviousSibling} () const {\bkmkstart AAAAAAAAFA}
{\bkmkend AAAAAAAAFA}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b XMLConstHandle} {\b PreviousSiblingElement} (const char *name=0) const {\bkmkstart AAAAAAAAFB}
{\bkmkend AAAAAAAAFB}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b XMLConstHandle} {\b NextSibling} () const {\bkmkstart AAAAAAAAFC}
{\bkmkend AAAAAAAAFC}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b XMLConstHandle} {\b NextSiblingElement} (const char *name=0) const {\bkmkstart AAAAAAAAFD}
{\bkmkend AAAAAAAAFD}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b XMLNode} * {\b ToNode} () const {\bkmkstart AAAAAAAAFE}
{\bkmkend AAAAAAAAFE}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b XMLElement} * {\b ToElement} () const {\bkmkstart AAAAAAAAFF}
{\bkmkend AAAAAAAAFF}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b XMLText} * {\b ToText} () const {\bkmkstart AAAAAAAAFG}
{\bkmkend AAAAAAAAFG}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b XMLUnknown} * {\b ToUnknown} () const {\bkmkstart AAAAAAAAFH}
{\bkmkend AAAAAAAAFH}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b XMLDeclaration} * {\b ToDeclaration} () const {\bkmkstart AAAAAAAAFI}
{\bkmkend AAAAAAAAFI}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A variant of the {\b XMLHandle} class for working with const XMLNodes and Documents. It is the same in all regards, except for the 'const' qualifiers. See {\b XMLHandle} for API. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
tinyxml2.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
tinyxml2::XMLDeclaration Class Reference\par \pard\plain 
{\tc\tcl2 \v tinyxml2::XMLDeclaration}
{\xe \v tinyxml2::XMLDeclaration}
{\bkmkstart AAAAAAAAFJ}
{\bkmkend AAAAAAAAFJ}
\par
{
{\f2 #include <tinyxml2.h>}}\par
Inheritance diagram for tinyxml2::XMLDeclaration:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classtinyxml2_1_1_x_m_l_declaration.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual {\b XMLDeclaration} * {\b ToDeclaration} (){\bkmkstart AAAAAAAAFK}
{\bkmkend AAAAAAAAFK}
\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Safely cast to a Declaration, or null. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const {\b XMLDeclaration} * {\b ToDeclaration} () const {\bkmkstart AAAAAAAAFL}
{\bkmkend AAAAAAAAFL}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b Accept} ({\b XMLVisitor} *visitor) const \par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b XMLNode} * {\b ShallowClone} ({\b XMLDocument} *document) const \par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b ShallowEqual} (const {\b XMLNode} *compare) const \par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b XMLDeclaration} ({\b XMLDocument} *doc){\bkmkstart AAAAAAAAFM}
{\bkmkend AAAAAAAAFM}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

char * {\b ParseDeep} (char *, {\b StrPair} *endTag){\bkmkstart AAAAAAAAFN}
{\bkmkend AAAAAAAAFN}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

class {\b XMLDocument}{\bkmkstart AAAAAAAAFO}
{\bkmkend AAAAAAAAFO}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
In correct XML the declaration is the first entry in the file. {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     <?xml version="1.0" standalone="yes"?>\par
}
\par
TinyXML-2 will happily read or write files without a declaration, however.\par
The text of the declaration isn't interpreted. It is parsed and written as a string. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v Accept\:tinyxml2::XMLDeclaration}
{\xe \v tinyxml2::XMLDeclaration\:Accept}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool tinyxml2::XMLDeclaration::Accept ({\b XMLVisitor} *  {\i visitor}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAFP}
{\bkmkend AAAAAAAAFP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Accept a hierarchical visit of the nodes in the TinyXML-2 DOM. Every node in the XML tree will be conditionally visited and the host will be called back via the {\b XMLVisitor} interface.\par
This is essentially a SAX interface for TinyXML-2. (Note however it doesn't re-parse the XML for the callbacks, so the performance of TinyXML-2 is unchanged by using this interface versus any other.)\par
The interface has been based on ideas from:\par
{
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\f2 http://www.saxproject.org/}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\f2 http://c2.com/cgi/wiki?HierarchicalVisitorPattern}\par}
Which are both good references for "visiting".\par
An example of using {\b Accept()}: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid XMLPrinter printer;\par
tinyxmlDoc.Accept( &printer );\par
const char* xmlcstr = printer.CStr();\par
}
 \par
}{
Implements {\b tinyxml2::XMLNode} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEM \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v ShallowClone\:tinyxml2::XMLDeclaration}
{\xe \v tinyxml2::XMLDeclaration\:ShallowClone}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b XMLNode} * tinyxml2::XMLDeclaration::ShallowClone ({\b XMLDocument} *  {\i document}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAFQ}
{\bkmkend AAAAAAAAFQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Make a copy of this node, but not its children. You may pass in a Document pointer that will be the owner of the new Node. If the 'document' is null, then the node returned will be allocated from the current Document. (this->{\b GetDocument()})\par
Note: if called on a {\b XMLDocument}, this will return null. \par
}{
Implements {\b tinyxml2::XMLNode} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEO \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v ShallowEqual\:tinyxml2::XMLDeclaration}
{\xe \v tinyxml2::XMLDeclaration\:ShallowEqual}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool tinyxml2::XMLDeclaration::ShallowEqual (const {\b XMLNode} *  {\i compare}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAFR}
{\bkmkend AAAAAAAAFR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Test if 2 nodes are the same, but don't test children. The 2 nodes do not need to be in the same Document.\par
Note: if called on a {\b XMLDocument}, this will return false. \par
}{
Implements {\b tinyxml2::XMLNode} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEQ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
tinyxml2.h\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
tinyxml2.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
tinyxml2::XMLDocument Class Reference\par \pard\plain 
{\tc\tcl2 \v tinyxml2::XMLDocument}
{\xe \v tinyxml2::XMLDocument}
{\bkmkstart AAAAAAAAFS}
{\bkmkend AAAAAAAAFS}
\par
{
{\f2 #include <tinyxml2.h>}}\par
Inheritance diagram for tinyxml2::XMLDocument:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classtinyxml2_1_1_x_m_l_document.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b XMLDocument} (bool processEntities=true, Whitespace=PRESERVE_WHITESPACE){\bkmkstart AAAAAAAAFT}
{\bkmkend AAAAAAAAFT}
\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
constructor }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual {\b XMLDocument} * {\b ToDocument} (){\bkmkstart AAAAAAAAFU}
{\bkmkend AAAAAAAAFU}
\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Safely cast to a Document, or null. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const {\b XMLDocument} * {\b ToDocument} () const {\bkmkstart AAAAAAAAFV}
{\bkmkend AAAAAAAAFV}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
XMLError {\b Parse} (const char *xml, size_t nBytes=(size_t)(-1))\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
XMLError {\b LoadFile} (const char *filename)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
XMLError {\b LoadFile} (FILE *)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
XMLError {\b SaveFile} (const char *filename, bool compact=false)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
XMLError {\b SaveFile} (FILE *fp, bool compact=false)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b ProcessEntities} () const {\bkmkstart AAAAAAAAFW}
{\bkmkend AAAAAAAAFW}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

Whitespace {\b WhitespaceMode} () const {\bkmkstart AAAAAAAAFX}
{\bkmkend AAAAAAAAFX}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b HasBOM} () const \par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetBOM} (bool useBOM)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMLElement} * {\b RootElement} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b XMLElement} * {\b RootElement} () const {\bkmkstart AAAAAAAAFY}
{\bkmkend AAAAAAAAFY}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Print} ({\b XMLPrinter} *streamer=0) const \par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b Accept} ({\b XMLVisitor} *visitor) const \par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMLElement} * {\b NewElement} (const char *name)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMLComment} * {\b NewComment} (const char *comment)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMLText} * {\b NewText} (const char *text)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMLDeclaration} * {\b NewDeclaration} (const char *text=0)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMLUnknown} * {\b NewUnknown} (const char *text)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b DeleteNode} ({\b XMLNode} *node)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b SetError} (XMLError error, const char *str1, const char *str2){\bkmkstart AAAAAAAAFZ}
{\bkmkend AAAAAAAAFZ}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b ClearError} (){\bkmkstart AAAAAAAAGA}
{\bkmkend AAAAAAAAGA}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b Error} () const {\bkmkstart AAAAAAAAGB}
{\bkmkend AAAAAAAAGB}
\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return true if there was an error parsing the document. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

XMLError {\b ErrorID} () const {\bkmkstart AAAAAAAAGC}
{\bkmkend AAAAAAAAGC}
\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return the errorID. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const char * {\b ErrorName} () const {\bkmkstart AAAAAAAAGD}
{\bkmkend AAAAAAAAGD}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const char * {\b GetErrorStr1} () const {\bkmkstart AAAAAAAAGE}
{\bkmkend AAAAAAAAGE}
\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return a possibly helpful diagnostic location or string. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const char * {\b GetErrorStr2} () const {\bkmkstart AAAAAAAAGF}
{\bkmkend AAAAAAAAGF}
\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return a possibly helpful secondary diagnostic location or string. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b PrintError} () const {\bkmkstart AAAAAAAAGG}
{\bkmkend AAAAAAAAGG}
\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If there is an error, print it to stdout. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b Clear} (){\bkmkstart AAAAAAAAGH}
{\bkmkend AAAAAAAAGH}
\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Clear the document, resetting it to the initial state. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

char * {\b Identify} (char *p, {\b XMLNode} **node){\bkmkstart AAAAAAAAGI}
{\bkmkend AAAAAAAAGI}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b XMLNode} * {\b ShallowClone} ({\b XMLDocument} *) const \par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b ShallowEqual} (const {\b XMLNode} *) const \par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

class {\b XMLElement}{\bkmkstart AAAAAAAAGJ}
{\bkmkend AAAAAAAAGJ}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A Document binds together all the functionality. It can be saved, loaded, and printed to the screen. All Nodes are connected and allocated to a Document. If the Document is deleted, all its Nodes are also deleted. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v Accept\:tinyxml2::XMLDocument}
{\xe \v tinyxml2::XMLDocument\:Accept}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool tinyxml2::XMLDocument::Accept ({\b XMLVisitor} *  {\i visitor}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAGK}
{\bkmkend AAAAAAAAGK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Accept a hierarchical visit of the nodes in the TinyXML-2 DOM. Every node in the XML tree will be conditionally visited and the host will be called back via the {\b XMLVisitor} interface.\par
This is essentially a SAX interface for TinyXML-2. (Note however it doesn't re-parse the XML for the callbacks, so the performance of TinyXML-2 is unchanged by using this interface versus any other.)\par
The interface has been based on ideas from:\par
{
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\f2 http://www.saxproject.org/}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\f2 http://c2.com/cgi/wiki?HierarchicalVisitorPattern}\par}
Which are both good references for "visiting".\par
An example of using {\b Accept()}: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid XMLPrinter printer;\par
tinyxmlDoc.Accept( &printer );\par
const char* xmlcstr = printer.CStr();\par
}
 \par
}{
Implements {\b tinyxml2::XMLNode} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEM \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v DeleteNode\:tinyxml2::XMLDocument}
{\xe \v tinyxml2::XMLDocument\:DeleteNode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void tinyxml2::XMLDocument::DeleteNode ({\b XMLNode} *  {\i node})}}
\par
{\bkmkstart AAAAAAAAGL}
{\bkmkend AAAAAAAAGL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Delete a node associated with this document. It will be unlinked from the DOM. \par
}}
{\xe \v HasBOM\:tinyxml2::XMLDocument}
{\xe \v tinyxml2::XMLDocument\:HasBOM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool tinyxml2::XMLDocument::HasBOM () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAGM}
{\bkmkend AAAAAAAAGM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if this document has a leading Byte Order Mark of UTF8. \par
}}
{\xe \v LoadFile\:tinyxml2::XMLDocument}
{\xe \v tinyxml2::XMLDocument\:LoadFile}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
XMLError tinyxml2::XMLDocument::LoadFile (const char *  {\i filename})}}
\par
{\bkmkstart AAAAAAAAGN}
{\bkmkend AAAAAAAAGN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Load an XML file from disk. Returns XML_SUCCESS (0) on success, or an errorID. \par
}}
{\xe \v LoadFile\:tinyxml2::XMLDocument}
{\xe \v tinyxml2::XMLDocument\:LoadFile}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
XMLError tinyxml2::XMLDocument::LoadFile (FILE *  {\i fp})}}
\par
{\bkmkstart AAAAAAAAGO}
{\bkmkend AAAAAAAAGO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Load an XML file from disk. You are responsible for providing and closing the FILE*.\par
NOTE: The file should be opened as binary ("rb") not text in order for TinyXML-2 to correctly do newline normalization.\par
Returns XML_SUCCESS (0) on success, or an errorID. \par
}}
{\xe \v NewComment\:tinyxml2::XMLDocument}
{\xe \v tinyxml2::XMLDocument\:NewComment}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b XMLComment} * tinyxml2::XMLDocument::NewComment (const char *  {\i comment})}}
\par
{\bkmkstart AAAAAAAAGP}
{\bkmkend AAAAAAAAGP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create a new Comment associated with this Document. The memory for the Comment is managed by the Document. \par
}}
{\xe \v NewDeclaration\:tinyxml2::XMLDocument}
{\xe \v tinyxml2::XMLDocument\:NewDeclaration}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b XMLDeclaration} * tinyxml2::XMLDocument::NewDeclaration (const char *  {\i text} = {\f2 0})}}
\par
{\bkmkstart AAAAAAAAGQ}
{\bkmkend AAAAAAAAGQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create a new Declaration associated with this Document. The memory for the object is managed by the Document.\par
If the 'text' param is null, the standard declaration is used.: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     <?xml version="1.0" encoding="UTF-8"?>\par
}
 \par
}}
{\xe \v NewElement\:tinyxml2::XMLDocument}
{\xe \v tinyxml2::XMLDocument\:NewElement}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b XMLElement} * tinyxml2::XMLDocument::NewElement (const char *  {\i name})}}
\par
{\bkmkstart AAAAAAAAGR}
{\bkmkend AAAAAAAAGR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create a new Element associated with this Document. The memory for the Element is managed by the Document. \par
}}
{\xe \v NewText\:tinyxml2::XMLDocument}
{\xe \v tinyxml2::XMLDocument\:NewText}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b XMLText} * tinyxml2::XMLDocument::NewText (const char *  {\i text})}}
\par
{\bkmkstart AAAAAAAAGS}
{\bkmkend AAAAAAAAGS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create a new Text associated with this Document. The memory for the Text is managed by the Document. \par
}}
{\xe \v NewUnknown\:tinyxml2::XMLDocument}
{\xe \v tinyxml2::XMLDocument\:NewUnknown}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b XMLUnknown} * tinyxml2::XMLDocument::NewUnknown (const char *  {\i text})}}
\par
{\bkmkstart AAAAAAAAGT}
{\bkmkend AAAAAAAAGT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create a new Unknown associated with this Document. The memory for the object is managed by the Document. \par
}}
{\xe \v Parse\:tinyxml2::XMLDocument}
{\xe \v tinyxml2::XMLDocument\:Parse}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
XMLError tinyxml2::XMLDocument::Parse (const char *  {\i xml}, size_t  {\i nBytes} = {\f2 (size_t)(-1)})}}
\par
{\bkmkstart AAAAAAAAGU}
{\bkmkend AAAAAAAAGU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Parse an XML file from a character string. Returns XML_SUCCESS (0) on success, or an errorID.\par
You may optionally pass in the 'nBytes', which is the number of bytes which will be parsed. If not specified, TinyXML-2 will assume 'xml' points to a null terminated string. \par
}}
{\xe \v Print\:tinyxml2::XMLDocument}
{\xe \v tinyxml2::XMLDocument\:Print}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void tinyxml2::XMLDocument::Print ({\b XMLPrinter} *  {\i streamer} = {\f2 0}) const}}
\par
{\bkmkstart AAAAAAAAGV}
{\bkmkend AAAAAAAAGV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Print the Document. If the Printer is not provided, it will print to stdout. If you provide Printer, this can print to a file: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid XMLPrinter printer( fp );\par
doc.Print( &printer );\par
}
\par
Or you can use a printer to print to memory: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid XMLPrinter printer;\par
doc.Print( &printer );\par
// printer.CStr() has a const char* to the XML\par
}
 \par
}}
{\xe \v RootElement\:tinyxml2::XMLDocument}
{\xe \v tinyxml2::XMLDocument\:RootElement}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b XMLElement}* tinyxml2::XMLDocument::RootElement (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAGW}
{\bkmkend AAAAAAAAGW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return the root element of DOM. Equivalent to {\b FirstChildElement()}. To get the first node, use FirstChild(). \par
}}
{\xe \v SaveFile\:tinyxml2::XMLDocument}
{\xe \v tinyxml2::XMLDocument\:SaveFile}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
XMLError tinyxml2::XMLDocument::SaveFile (const char *  {\i filename}, bool  {\i compact} = {\f2 false})}}
\par
{\bkmkstart AAAAAAAAGX}
{\bkmkend AAAAAAAAGX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Save the XML file to disk. Returns XML_SUCCESS (0) on success, or an errorID. \par
}}
{\xe \v SaveFile\:tinyxml2::XMLDocument}
{\xe \v tinyxml2::XMLDocument\:SaveFile}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
XMLError tinyxml2::XMLDocument::SaveFile (FILE *  {\i fp}, bool  {\i compact} = {\f2 false})}}
\par
{\bkmkstart AAAAAAAAGY}
{\bkmkend AAAAAAAAGY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Save the XML file to disk. You are responsible for providing and closing the FILE*.\par
Returns XML_SUCCESS (0) on success, or an errorID. \par
}}
{\xe \v SetBOM\:tinyxml2::XMLDocument}
{\xe \v tinyxml2::XMLDocument\:SetBOM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void tinyxml2::XMLDocument::SetBOM (bool  {\i useBOM}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAGZ}
{\bkmkend AAAAAAAAGZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets whether to write the BOM when writing the file. \par
}}
{\xe \v ShallowClone\:tinyxml2::XMLDocument}
{\xe \v tinyxml2::XMLDocument\:ShallowClone}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual {\b XMLNode}* tinyxml2::XMLDocument::ShallowClone ({\b XMLDocument} *  {\i document}) const{\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAHA}
{\bkmkend AAAAAAAAHA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Make a copy of this node, but not its children. You may pass in a Document pointer that will be the owner of the new Node. If the 'document' is null, then the node returned will be allocated from the current Document. (this->{\b GetDocument()})\par
Note: if called on a {\b XMLDocument}, this will return null. \par
}{
Implements {\b tinyxml2::XMLNode} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEO \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v ShallowEqual\:tinyxml2::XMLDocument}
{\xe \v tinyxml2::XMLDocument\:ShallowEqual}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual bool tinyxml2::XMLDocument::ShallowEqual (const {\b XMLNode} *  {\i compare}) const{\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAHB}
{\bkmkend AAAAAAAAHB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Test if 2 nodes are the same, but don't test children. The 2 nodes do not need to be in the same Document.\par
Note: if called on a {\b XMLDocument}, this will return false. \par
}{
Implements {\b tinyxml2::XMLNode} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEQ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
tinyxml2.h\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
tinyxml2.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
tinyxml2::XMLElement Class Reference\par \pard\plain 
{\tc\tcl2 \v tinyxml2::XMLElement}
{\xe \v tinyxml2::XMLElement}
{\bkmkstart AAAAAAAAHC}
{\bkmkend AAAAAAAAHC}
\par
{
{\f2 #include <tinyxml2.h>}}\par
Inheritance diagram for tinyxml2::XMLElement:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classtinyxml2_1_1_x_m_l_element.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum \{ {\b OPEN}, 
{\b CLOSED}, 
{\b CLOSING}
 \}{\bkmkstart AAAAAAAAHD}
{\bkmkend AAAAAAAAHD}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const char * {\b Name} () const {\bkmkstart AAAAAAAAHE}
{\bkmkend AAAAAAAAHE}
\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the name of an element (which is the {\b Value()} of the node.) }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b SetName} (const char *str, bool staticMem=false){\bkmkstart AAAAAAAAHF}
{\bkmkend AAAAAAAAHF}
\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set the name of the element. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual {\b XMLElement} * {\b ToElement} (){\bkmkstart AAAAAAAAHG}
{\bkmkend AAAAAAAAHG}
\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Safely cast to an Element, or null. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const {\b XMLElement} * {\b ToElement} () const {\bkmkstart AAAAAAAAHH}
{\bkmkend AAAAAAAAHH}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b Accept} ({\b XMLVisitor} *visitor) const \par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b Attribute} (const char *name, const char *value=0) const \par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b IntAttribute} (const char *name, int defaultValue=0) const \par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

unsigned {\b UnsignedAttribute} (const char *name, unsigned defaultValue=0) const {\bkmkstart AAAAAAAAHI}
{\bkmkend AAAAAAAAHI}
\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
See {\b IntAttribute()} }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int64_t {\b Int64Attribute} (const char *name, int64_t defaultValue=0) const {\bkmkstart AAAAAAAAHJ}
{\bkmkend AAAAAAAAHJ}
\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
See {\b IntAttribute()} }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b BoolAttribute} (const char *name, bool defaultValue=false) const {\bkmkstart AAAAAAAAHK}
{\bkmkend AAAAAAAAHK}
\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
See {\b IntAttribute()} }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

double {\b DoubleAttribute} (const char *name, double defaultValue=0) const {\bkmkstart AAAAAAAAHL}
{\bkmkend AAAAAAAAHL}
\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
See {\b IntAttribute()} }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

float {\b FloatAttribute} (const char *name, float defaultValue=0) const {\bkmkstart AAAAAAAAHM}
{\bkmkend AAAAAAAAHM}
\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
See {\b IntAttribute()} }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
XMLError {\b QueryIntAttribute} (const char *name, int *value) const \par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

XMLError {\b QueryUnsignedAttribute} (const char *name, unsigned int *value) const {\bkmkstart AAAAAAAAHN}
{\bkmkend AAAAAAAAHN}
\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
See {\b QueryIntAttribute()} }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

XMLError {\b QueryInt64Attribute} (const char *name, int64_t *value) const {\bkmkstart AAAAAAAAHO}
{\bkmkend AAAAAAAAHO}
\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
See {\b QueryIntAttribute()} }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

XMLError {\b QueryBoolAttribute} (const char *name, bool *value) const {\bkmkstart AAAAAAAAHP}
{\bkmkend AAAAAAAAHP}
\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
See {\b QueryIntAttribute()} }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

XMLError {\b QueryDoubleAttribute} (const char *name, double *value) const {\bkmkstart AAAAAAAAHQ}
{\bkmkend AAAAAAAAHQ}
\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
See {\b QueryIntAttribute()} }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

XMLError {\b QueryFloatAttribute} (const char *name, float *value) const {\bkmkstart AAAAAAAAHR}
{\bkmkend AAAAAAAAHR}
\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
See {\b QueryIntAttribute()} }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b QueryAttribute} (const char *name, int *value) const \par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int {\b QueryAttribute} (const char *name, unsigned int *value) const {\bkmkstart AAAAAAAAHS}
{\bkmkend AAAAAAAAHS}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int {\b QueryAttribute} (const char *name, int64_t *value) const {\bkmkstart AAAAAAAAHT}
{\bkmkend AAAAAAAAHT}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int {\b QueryAttribute} (const char *name, bool *value) const {\bkmkstart AAAAAAAAHU}
{\bkmkend AAAAAAAAHU}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int {\b QueryAttribute} (const char *name, double *value) const {\bkmkstart AAAAAAAAHV}
{\bkmkend AAAAAAAAHV}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int {\b QueryAttribute} (const char *name, float *value) const {\bkmkstart AAAAAAAAHW}
{\bkmkend AAAAAAAAHW}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b SetAttribute} (const char *name, const char *value){\bkmkstart AAAAAAAAHX}
{\bkmkend AAAAAAAAHX}
\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the named attribute to value. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b SetAttribute} (const char *name, int value){\bkmkstart AAAAAAAAHY}
{\bkmkend AAAAAAAAHY}
\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the named attribute to value. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b SetAttribute} (const char *name, unsigned value){\bkmkstart AAAAAAAAHZ}
{\bkmkend AAAAAAAAHZ}
\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the named attribute to value. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b SetAttribute} (const char *name, int64_t value){\bkmkstart AAAAAAAAIA}
{\bkmkend AAAAAAAAIA}
\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the named attribute to value. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b SetAttribute} (const char *name, bool value){\bkmkstart AAAAAAAAIB}
{\bkmkend AAAAAAAAIB}
\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the named attribute to value. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b SetAttribute} (const char *name, double value){\bkmkstart AAAAAAAAIC}
{\bkmkend AAAAAAAAIC}
\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the named attribute to value. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b SetAttribute} (const char *name, float value){\bkmkstart AAAAAAAAID}
{\bkmkend AAAAAAAAID}
\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the named attribute to value. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b DeleteAttribute} (const char *name)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b XMLAttribute} * {\b FirstAttribute} () const {\bkmkstart AAAAAAAAIE}
{\bkmkend AAAAAAAAIE}
\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return the first attribute in the list. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b XMLAttribute} * {\b FindAttribute} (const char *name) const {\bkmkstart AAAAAAAAIF}
{\bkmkend AAAAAAAAIF}
\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Query a specific attribute in the list. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b GetText} () const \par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetText} (const char *inText)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b SetText} (int value){\bkmkstart AAAAAAAAIG}
{\bkmkend AAAAAAAAIG}
\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Convenience method for setting text inside an element. See {\b SetText()} for important limitations. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b SetText} (unsigned value){\bkmkstart AAAAAAAAIH}
{\bkmkend AAAAAAAAIH}
\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Convenience method for setting text inside an element. See {\b SetText()} for important limitations. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b SetText} (int64_t value){\bkmkstart AAAAAAAAII}
{\bkmkend AAAAAAAAII}
\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Convenience method for setting text inside an element. See {\b SetText()} for important limitations. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b SetText} (bool value){\bkmkstart AAAAAAAAIJ}
{\bkmkend AAAAAAAAIJ}
\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Convenience method for setting text inside an element. See {\b SetText()} for important limitations. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b SetText} (double value){\bkmkstart AAAAAAAAIK}
{\bkmkend AAAAAAAAIK}
\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Convenience method for setting text inside an element. See {\b SetText()} for important limitations. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b SetText} (float value){\bkmkstart AAAAAAAAIL}
{\bkmkend AAAAAAAAIL}
\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Convenience method for setting text inside an element. See {\b SetText()} for important limitations. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
XMLError {\b QueryIntText} (int *ival) const \par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

XMLError {\b QueryUnsignedText} (unsigned *uval) const {\bkmkstart AAAAAAAAIM}
{\bkmkend AAAAAAAAIM}
\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
See {\b QueryIntText()} }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

XMLError {\b QueryInt64Text} (int64_t *uval) const {\bkmkstart AAAAAAAAIN}
{\bkmkend AAAAAAAAIN}
\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
See {\b QueryIntText()} }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

XMLError {\b QueryBoolText} (bool *bval) const {\bkmkstart AAAAAAAAIO}
{\bkmkend AAAAAAAAIO}
\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
See {\b QueryIntText()} }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

XMLError {\b QueryDoubleText} (double *dval) const {\bkmkstart AAAAAAAAIP}
{\bkmkend AAAAAAAAIP}
\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
See {\b QueryIntText()} }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

XMLError {\b QueryFloatText} (float *fval) const {\bkmkstart AAAAAAAAIQ}
{\bkmkend AAAAAAAAIQ}
\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
See {\b QueryIntText()} }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int {\b IntText} (int defaultValue=0) const {\bkmkstart AAAAAAAAIR}
{\bkmkend AAAAAAAAIR}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

unsigned {\b UnsignedText} (unsigned defaultValue=0) const {\bkmkstart AAAAAAAAIS}
{\bkmkend AAAAAAAAIS}
\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
See {\b QueryIntText()} }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int64_t {\b Int64Text} (int64_t defaultValue=0) const {\bkmkstart AAAAAAAAIT}
{\bkmkend AAAAAAAAIT}
\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
See {\b QueryIntText()} }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b BoolText} (bool defaultValue=false) const {\bkmkstart AAAAAAAAIU}
{\bkmkend AAAAAAAAIU}
\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
See {\b QueryIntText()} }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

double {\b DoubleText} (double defaultValue=0) const {\bkmkstart AAAAAAAAIV}
{\bkmkend AAAAAAAAIV}
\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
See {\b QueryIntText()} }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

float {\b FloatText} (float defaultValue=0) const {\bkmkstart AAAAAAAAIW}
{\bkmkend AAAAAAAAIW}
\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
See {\b QueryIntText()} }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int {\b ClosingType} () const {\bkmkstart AAAAAAAAIX}
{\bkmkend AAAAAAAAIX}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b XMLNode} * {\b ShallowClone} ({\b XMLDocument} *document) const \par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b ShallowEqual} (const {\b XMLNode} *compare) const \par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

char * {\b ParseDeep} (char *p, {\b StrPair} *endTag){\bkmkstart AAAAAAAAIY}
{\bkmkend AAAAAAAAIY}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

class {\b XMLDocument}{\bkmkstart AAAAAAAAIZ}
{\bkmkend AAAAAAAAIZ}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The element is a container class. It has a value, the element name, and can contain other elements, text, comments, and unknowns. Elements also contain an arbitrary number of attributes. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v Accept\:tinyxml2::XMLElement}
{\xe \v tinyxml2::XMLElement\:Accept}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool tinyxml2::XMLElement::Accept ({\b XMLVisitor} *  {\i visitor}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAJA}
{\bkmkend AAAAAAAAJA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Accept a hierarchical visit of the nodes in the TinyXML-2 DOM. Every node in the XML tree will be conditionally visited and the host will be called back via the {\b XMLVisitor} interface.\par
This is essentially a SAX interface for TinyXML-2. (Note however it doesn't re-parse the XML for the callbacks, so the performance of TinyXML-2 is unchanged by using this interface versus any other.)\par
The interface has been based on ideas from:\par
{
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\f2 http://www.saxproject.org/}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\f2 http://c2.com/cgi/wiki?HierarchicalVisitorPattern}\par}
Which are both good references for "visiting".\par
An example of using {\b Accept()}: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid XMLPrinter printer;\par
tinyxmlDoc.Accept( &printer );\par
const char* xmlcstr = printer.CStr();\par
}
 \par
}{
Implements {\b tinyxml2::XMLNode} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEM \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v Attribute\:tinyxml2::XMLElement}
{\xe \v tinyxml2::XMLElement\:Attribute}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char * tinyxml2::XMLElement::Attribute (const char *  {\i name}, const char *  {\i value} = {\f2 0}) const}}
\par
{\bkmkstart AAAAAAAAJB}
{\bkmkend AAAAAAAAJB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Given an attribute name, {\b Attribute()} returns the value for the attribute of that name, or null if none exists. For example:\par
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid const char* value = ele->Attribute( "foo" );\par
}
\par
The 'value' parameter is normally null. However, if specified, the attribute will only be returned if the 'name' and 'value' match. This allow you to write code:\par
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid if ( ele->Attribute( "foo", "bar" ) ) callFooIsBar();\par
}
\par
rather than: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid if ( ele->Attribute( "foo" ) ) \{\par
    if ( strcmp( ele->Attribute( "foo" ), "bar" ) == 0 ) callFooIsBar();\par
\}\par
}
 \par
}}
{\xe \v DeleteAttribute\:tinyxml2::XMLElement}
{\xe \v tinyxml2::XMLElement\:DeleteAttribute}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void tinyxml2::XMLElement::DeleteAttribute (const char *  {\i name})}}
\par
{\bkmkstart AAAAAAAAJC}
{\bkmkend AAAAAAAAJC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Delete an attribute. \par
}}
{\xe \v GetText\:tinyxml2::XMLElement}
{\xe \v tinyxml2::XMLElement\:GetText}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char * tinyxml2::XMLElement::GetText () const}}
\par
{\bkmkstart AAAAAAAAJD}
{\bkmkend AAAAAAAAJD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Convenience function for easy access to the text inside an element. Although easy and concise, {\b GetText()} is limited compared to getting the {\b XMLText} child and accessing it directly.\par
If the first child of 'this' is a {\b XMLText}, the {\b GetText()} returns the character string of the Text node, else null is returned.\par
This is a convenient method for getting the text of simple contained text: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid <foo>This is text</foo>\par
    const char* str = fooElement->GetText();\par
}
\par
'str' will be a pointer to "This is text".\par
Note that this function can be misleading. If the element foo was created from this XML: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     <foo><b>This is text</b></foo>\par
}
\par
then the value of str would be null. The first child node isn't a text node, it is another element. From this XML: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     <foo>This is <b>text</b></foo>\par
}
 {\b GetText()} will return "This is ". \par
}}
{\xe \v IntAttribute\:tinyxml2::XMLElement}
{\xe \v tinyxml2::XMLElement\:IntAttribute}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int tinyxml2::XMLElement::IntAttribute (const char *  {\i name}, int  {\i defaultValue} = {\f2 0}) const}}
\par
{\bkmkstart AAAAAAAAJE}
{\bkmkend AAAAAAAAJE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Given an attribute name, {\b IntAttribute()} returns the value of the attribute interpreted as an integer. The default value will be returned if the attribute isn't present, or if there is an error. (For a method with error checking, see {\b QueryIntAttribute()}). \par
}}
{\xe \v QueryAttribute\:tinyxml2::XMLElement}
{\xe \v tinyxml2::XMLElement\:QueryAttribute}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int tinyxml2::XMLElement::QueryAttribute (const char *  {\i name}, int *  {\i value}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAJF}
{\bkmkend AAAAAAAAJF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Given an attribute name, {\b QueryAttribute()} returns XML_SUCCESS, XML_WRONG_ATTRIBUTE_TYPE if the conversion can't be performed, or XML_NO_ATTRIBUTE if the attribute doesn't exist. It is overloaded for the primitive types, and is a generally more convenient replacement of {\b QueryIntAttribute()} and related functions.\par
If successful, the result of the conversion will be written to 'value'. If not successful, nothing will be written to 'value'. This allows you to provide default value:\par
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid int value = 10;\par
QueryAttribute( "foo", &value );        // if "foo" isn't found, value will still be 10\par
}
 \par
}}
{\xe \v QueryIntAttribute\:tinyxml2::XMLElement}
{\xe \v tinyxml2::XMLElement\:QueryIntAttribute}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
XMLError tinyxml2::XMLElement::QueryIntAttribute (const char *  {\i name}, int *  {\i value}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAJG}
{\bkmkend AAAAAAAAJG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Given an attribute name, {\b QueryIntAttribute()} returns XML_SUCCESS, XML_WRONG_ATTRIBUTE_TYPE if the conversion can't be performed, or XML_NO_ATTRIBUTE if the attribute doesn't exist. If successful, the result of the conversion will be written to 'value'. If not successful, nothing will be written to 'value'. This allows you to provide default value:\par
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid int value = 10;\par
QueryIntAttribute( "foo", &value );     // if "foo" isn't found, value will still be 10\par
}
 \par
}}
{\xe \v QueryIntText\:tinyxml2::XMLElement}
{\xe \v tinyxml2::XMLElement\:QueryIntText}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
XMLError tinyxml2::XMLElement::QueryIntText (int *  {\i ival}) const}}
\par
{\bkmkstart AAAAAAAAJH}
{\bkmkend AAAAAAAAJH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Convenience method to query the value of a child text node. This is probably best shown by example. Given you have a document is this form: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     <point>\par
        <x>1</x>\par
        <y>1.4</y>\par
    </point>\par
}
\par
The {\b QueryIntText()} and similar functions provide a safe and easier way to get to the "value" of x and y.\par
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     int x = 0;\par
    float y = 0;    // types of x and y are contrived for example\par
    const XMLElement* xElement = pointElement->FirstChildElement( "x" );\par
    const XMLElement* yElement = pointElement->FirstChildElement( "y" );\par
    xElement->QueryIntText( &x );\par
    yElement->QueryFloatText( &y );\par
}
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid XML_SUCCESS (0) on success, XML_CAN_NOT_CONVERT_TEXT if the text cannot be converted to the requested type, and XML_NO_TEXT_NODE if there is no child text to query. \par
}}}
{\xe \v SetText\:tinyxml2::XMLElement}
{\xe \v tinyxml2::XMLElement\:SetText}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void tinyxml2::XMLElement::SetText (const char *  {\i inText})}}
\par
{\bkmkstart AAAAAAAAJI}
{\bkmkend AAAAAAAAJI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Convenience function for easy access to the text inside an element. Although easy and concise, {\b SetText()} is limited compared to creating an {\b XMLText} child and mutating it directly.\par
If the first child of 'this' is a {\b XMLText}, {\b SetText()} sets its value to the given string, otherwise it will create a first child that is an {\b XMLText}.\par
This is a convenient method for setting the text of simple contained text: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid <foo>This is text</foo>\par
    fooElement->SetText( "Hullaballoo!" );\par
<foo>Hullaballoo!</foo>\par
}
\par
Note that this function can be misleading. If the element foo was created from this XML: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     <foo><b>This is text</b></foo>\par
}
\par
then it will not change "This is text", but rather prefix it with a text element: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     <foo>Hullaballoo!<b>This is text</b></foo>\par
}
\par
For this XML: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     <foo />\par
}
 {\b SetText()} will generate {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     <foo>Hullaballoo!</foo>\par
}
 \par
}}
{\xe \v ShallowClone\:tinyxml2::XMLElement}
{\xe \v tinyxml2::XMLElement\:ShallowClone}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b XMLNode} * tinyxml2::XMLElement::ShallowClone ({\b XMLDocument} *  {\i document}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAJJ}
{\bkmkend AAAAAAAAJJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Make a copy of this node, but not its children. You may pass in a Document pointer that will be the owner of the new Node. If the 'document' is null, then the node returned will be allocated from the current Document. (this->{\b GetDocument()})\par
Note: if called on a {\b XMLDocument}, this will return null. \par
}{
Implements {\b tinyxml2::XMLNode} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEO \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v ShallowEqual\:tinyxml2::XMLElement}
{\xe \v tinyxml2::XMLElement\:ShallowEqual}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool tinyxml2::XMLElement::ShallowEqual (const {\b XMLNode} *  {\i compare}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAJK}
{\bkmkend AAAAAAAAJK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Test if 2 nodes are the same, but don't test children. The 2 nodes do not need to be in the same Document.\par
Note: if called on a {\b XMLDocument}, this will return false. \par
}{
Implements {\b tinyxml2::XMLNode} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEQ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
tinyxml2.h\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
tinyxml2.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
tinyxml2::XMLHandle Class Reference\par \pard\plain 
{\tc\tcl2 \v tinyxml2::XMLHandle}
{\xe \v tinyxml2::XMLHandle}
{\bkmkstart AAAAAAAAJL}
{\bkmkend AAAAAAAAJL}
\par
{
{\f2 #include <tinyxml2.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b XMLHandle} ({\b XMLNode} *node){\bkmkstart AAAAAAAAJM}
{\bkmkend AAAAAAAAJM}
\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create a handle from any node (at any depth of the tree.) This can be a null pointer. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b XMLHandle} ({\b XMLNode} &node){\bkmkstart AAAAAAAAJN}
{\bkmkend AAAAAAAAJN}
\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create a handle from a node. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b XMLHandle} (const {\b XMLHandle} &ref){\bkmkstart AAAAAAAAJO}
{\bkmkend AAAAAAAAJO}
\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Copy constructor. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b XMLHandle} & {\b operator=} (const {\b XMLHandle} &ref){\bkmkstart AAAAAAAAJP}
{\bkmkend AAAAAAAAJP}
\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Assignment. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b XMLHandle} {\b FirstChild} (){\bkmkstart AAAAAAAAJQ}
{\bkmkend AAAAAAAAJQ}
\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the first child of this handle. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b XMLHandle} {\b FirstChildElement} (const char *name=0){\bkmkstart AAAAAAAAJR}
{\bkmkend AAAAAAAAJR}
\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the first child element of this handle. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b XMLHandle} {\b LastChild} (){\bkmkstart AAAAAAAAJS}
{\bkmkend AAAAAAAAJS}
\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the last child of this handle. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b XMLHandle} {\b LastChildElement} (const char *name=0){\bkmkstart AAAAAAAAJT}
{\bkmkend AAAAAAAAJT}
\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the last child element of this handle. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b XMLHandle} {\b PreviousSibling} (){\bkmkstart AAAAAAAAJU}
{\bkmkend AAAAAAAAJU}
\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the previous sibling of this handle. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b XMLHandle} {\b PreviousSiblingElement} (const char *name=0){\bkmkstart AAAAAAAAJV}
{\bkmkend AAAAAAAAJV}
\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the previous sibling element of this handle. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b XMLHandle} {\b NextSibling} (){\bkmkstart AAAAAAAAJW}
{\bkmkend AAAAAAAAJW}
\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the next sibling of this handle. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b XMLHandle} {\b NextSiblingElement} (const char *name=0){\bkmkstart AAAAAAAAJX}
{\bkmkend AAAAAAAAJX}
\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the next sibling element of this handle. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b XMLNode} * {\b ToNode} (){\bkmkstart AAAAAAAAJY}
{\bkmkend AAAAAAAAJY}
\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Safe cast to {\b XMLNode}. This can return null. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b XMLElement} * {\b ToElement} (){\bkmkstart AAAAAAAAJZ}
{\bkmkend AAAAAAAAJZ}
\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Safe cast to {\b XMLElement}. This can return null. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b XMLText} * {\b ToText} (){\bkmkstart AAAAAAAAKA}
{\bkmkend AAAAAAAAKA}
\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Safe cast to {\b XMLText}. This can return null. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b XMLUnknown} * {\b ToUnknown} (){\bkmkstart AAAAAAAAKB}
{\bkmkend AAAAAAAAKB}
\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Safe cast to {\b XMLUnknown}. This can return null. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b XMLDeclaration} * {\b ToDeclaration} (){\bkmkstart AAAAAAAAKC}
{\bkmkend AAAAAAAAKC}
\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Safe cast to {\b XMLDeclaration}. This can return null. }{
}\par
}}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A {\b XMLHandle} is a class that wraps a node pointer with null checks; this is an incredibly useful thing. Note that {\b XMLHandle} is not part of the TinyXML-2 DOM structure. It is a separate utility class.\par
Take an example: {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid <Document>\par
    <Element attributeA = "valueA">\par
        <Child attributeB = "value1" />\par
        <Child attributeB = "value2" />\par
    </Element>\par
</Document>\par
}
\par
Assuming you want the value of "attributeB" in the 2nd "Child" element, it's very easy to write a {\i lot}  of code that looks like:\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid XMLElement* root = document.FirstChildElement( "Document" );\par
if ( root )\par
\{\par
    XMLElement* element = root->FirstChildElement( "Element" );\par
    if ( element )\par
    \{\par
        XMLElement* child = element->FirstChildElement( "Child" );\par
        if ( child )\par
        \{\par
            XMLElement* child2 = child->NextSiblingElement( "Child" );\par
            if ( child2 )\par
            \{\par
                // Finally do something useful.\par
}
\par
And that doesn't even cover "else" cases. {\b XMLHandle} addresses the verbosity of such code. A {\b XMLHandle} checks for null pointers so it is perfectly safe and correct to use:\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid XMLHandle docHandle( &document );\par
XMLElement* child2 = docHandle.FirstChildElement( "Document" ).FirstChildElement( "Element" ).FirstChildElement().NextSiblingElement();\par
if ( child2 )\par
\{\par
    // do something useful\par
}
\par
Which is MUCH more concise and useful.\par
It is also safe to copy handles - internally they are nothing more than node pointers. {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid XMLHandle handleCopy = handle;\par
}
\par
See also {\b XMLConstHandle}, which is the same as {\b XMLHandle}, but operates on const objects. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
tinyxml2.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
tinyxml2::XMLNode Class Reference\par \pard\plain 
{\tc\tcl2 \v tinyxml2::XMLNode}
{\xe \v tinyxml2::XMLNode}
{\bkmkstart AAAAAAAAKD}
{\bkmkend AAAAAAAAKD}
\par
{
{\f2 #include <tinyxml2.h>}}\par
Inheritance diagram for tinyxml2::XMLNode:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classtinyxml2_1_1_x_m_l_node.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b XMLDocument} * {\b GetDocument} () const {\bkmkstart AAAAAAAAKE}
{\bkmkend AAAAAAAAKE}
\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the {\b XMLDocument} that owns this {\b XMLNode}. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b XMLDocument} * {\b GetDocument} (){\bkmkstart AAAAAAAAKF}
{\bkmkend AAAAAAAAKF}
\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the {\b XMLDocument} that owns this {\b XMLNode}. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual {\b XMLElement} * {\b ToElement} (){\bkmkstart AAAAAAAAKG}
{\bkmkend AAAAAAAAKG}
\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Safely cast to an Element, or null. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual {\b XMLText} * {\b ToText} (){\bkmkstart AAAAAAAAKH}
{\bkmkend AAAAAAAAKH}
\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Safely cast to Text, or null. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual {\b XMLComment} * {\b ToComment} (){\bkmkstart AAAAAAAAKI}
{\bkmkend AAAAAAAAKI}
\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Safely cast to a Comment, or null. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual {\b XMLDocument} * {\b ToDocument} (){\bkmkstart AAAAAAAAKJ}
{\bkmkend AAAAAAAAKJ}
\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Safely cast to a Document, or null. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual {\b XMLDeclaration} * {\b ToDeclaration} (){\bkmkstart AAAAAAAAKK}
{\bkmkend AAAAAAAAKK}
\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Safely cast to a Declaration, or null. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual {\b XMLUnknown} * {\b ToUnknown} (){\bkmkstart AAAAAAAAKL}
{\bkmkend AAAAAAAAKL}
\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Safely cast to an Unknown, or null. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const {\b XMLElement} * {\b ToElement} () const {\bkmkstart AAAAAAAAKM}
{\bkmkend AAAAAAAAKM}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const {\b XMLText} * {\b ToText} () const {\bkmkstart AAAAAAAAKN}
{\bkmkend AAAAAAAAKN}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const {\b XMLComment} * {\b ToComment} () const {\bkmkstart AAAAAAAAKO}
{\bkmkend AAAAAAAAKO}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const {\b XMLDocument} * {\b ToDocument} () const {\bkmkstart AAAAAAAAKP}
{\bkmkend AAAAAAAAKP}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const {\b XMLDeclaration} * {\b ToDeclaration} () const {\bkmkstart AAAAAAAAKQ}
{\bkmkend AAAAAAAAKQ}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const {\b XMLUnknown} * {\b ToUnknown} () const {\bkmkstart AAAAAAAAKR}
{\bkmkend AAAAAAAAKR}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b Value} () const \par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetValue} (const char *val, bool staticMem=false)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b XMLNode} * {\b Parent} () const {\bkmkstart AAAAAAAAKS}
{\bkmkend AAAAAAAAKS}
\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the parent of this node on the DOM. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b XMLNode} * {\b Parent} (){\bkmkstart AAAAAAAAKT}
{\bkmkend AAAAAAAAKT}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b NoChildren} () const {\bkmkstart AAAAAAAAKU}
{\bkmkend AAAAAAAAKU}
\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if this node has no children. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b XMLNode} * {\b FirstChild} () const {\bkmkstart AAAAAAAAKV}
{\bkmkend AAAAAAAAKV}
\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the first child node, or null if none exists. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b XMLNode} * {\b FirstChild} (){\bkmkstart AAAAAAAAKW}
{\bkmkend AAAAAAAAKW}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b XMLElement} * {\b FirstChildElement} (const char *name=0) const \par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b XMLElement} * {\b FirstChildElement} (const char *name=0){\bkmkstart AAAAAAAAKX}
{\bkmkend AAAAAAAAKX}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b XMLNode} * {\b LastChild} () const {\bkmkstart AAAAAAAAKY}
{\bkmkend AAAAAAAAKY}
\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the last child node, or null if none exists. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b XMLNode} * {\b LastChild} (){\bkmkstart AAAAAAAAKZ}
{\bkmkend AAAAAAAAKZ}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b XMLElement} * {\b LastChildElement} (const char *name=0) const \par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b XMLElement} * {\b LastChildElement} (const char *name=0){\bkmkstart AAAAAAAALA}
{\bkmkend AAAAAAAALA}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b XMLNode} * {\b PreviousSibling} () const {\bkmkstart AAAAAAAALB}
{\bkmkend AAAAAAAALB}
\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the previous (left) sibling node of this node. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b XMLNode} * {\b PreviousSibling} (){\bkmkstart AAAAAAAALC}
{\bkmkend AAAAAAAALC}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b XMLElement} * {\b PreviousSiblingElement} (const char *name=0) const {\bkmkstart AAAAAAAALD}
{\bkmkend AAAAAAAALD}
\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the previous (left) sibling element of this node, with an optionally supplied name. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b XMLElement} * {\b PreviousSiblingElement} (const char *name=0){\bkmkstart AAAAAAAALE}
{\bkmkend AAAAAAAALE}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b XMLNode} * {\b NextSibling} () const {\bkmkstart AAAAAAAALF}
{\bkmkend AAAAAAAALF}
\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the next (right) sibling node of this node. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b XMLNode} * {\b NextSibling} (){\bkmkstart AAAAAAAALG}
{\bkmkend AAAAAAAALG}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b XMLElement} * {\b NextSiblingElement} (const char *name=0) const {\bkmkstart AAAAAAAALH}
{\bkmkend AAAAAAAALH}
\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the next (right) sibling element of this node, with an optionally supplied name. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b XMLElement} * {\b NextSiblingElement} (const char *name=0){\bkmkstart AAAAAAAALI}
{\bkmkend AAAAAAAALI}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMLNode} * {\b InsertEndChild} ({\b XMLNode} *addThis)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b XMLNode} * {\b LinkEndChild} ({\b XMLNode} *addThis){\bkmkstart AAAAAAAALJ}
{\bkmkend AAAAAAAALJ}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMLNode} * {\b InsertFirstChild} ({\b XMLNode} *addThis)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMLNode} * {\b InsertAfterChild} ({\b XMLNode} *afterThis, {\b XMLNode} *addThis)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b DeleteChildren} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b DeleteChild} ({\b XMLNode} *node)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b XMLNode} * {\b ShallowClone} ({\b XMLDocument} *document) const  =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b ShallowEqual} (const {\b XMLNode} *compare) const  =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b Accept} ({\b XMLVisitor} *visitor) const  =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetUserData} (void *userData)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void * {\b GetUserData} () const \par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b XMLNode} ({\b XMLDocument} *){\bkmkstart AAAAAAAALK}
{\bkmkend AAAAAAAALK}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual char * {\b ParseDeep} (char *, {\b StrPair} *){\bkmkstart AAAAAAAALL}
{\bkmkend AAAAAAAALL}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b XMLDocument} * {\b _document}{\bkmkstart AAAAAAAALM}
{\bkmkend AAAAAAAALM}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b XMLNode} * {\b _parent}{\bkmkstart AAAAAAAALN}
{\bkmkend AAAAAAAALN}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b StrPair} {\b _value}{\bkmkstart AAAAAAAALO}
{\bkmkend AAAAAAAALO}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b XMLNode} * {\b _firstChild}{\bkmkstart AAAAAAAALP}
{\bkmkend AAAAAAAALP}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b XMLNode} * {\b _lastChild}{\bkmkstart AAAAAAAALQ}
{\bkmkend AAAAAAAALQ}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b XMLNode} * {\b _prev}{\bkmkstart AAAAAAAALR}
{\bkmkend AAAAAAAALR}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b XMLNode} * {\b _next}{\bkmkstart AAAAAAAALS}
{\bkmkend AAAAAAAALS}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void * {\b _userData}{\bkmkstart AAAAAAAALT}
{\bkmkend AAAAAAAALT}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

class {\b XMLDocument}{\bkmkstart AAAAAAAALU}
{\bkmkend AAAAAAAALU}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

class {\b XMLElement}{\bkmkstart AAAAAAAALV}
{\bkmkend AAAAAAAALV}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b XMLNode} is a base class for every object that is in the XML Document Object Model (DOM), except XMLAttributes. Nodes have siblings, a parent, and children which can be navigated. A node is always in a {\b XMLDocument}. The type of a {\b XMLNode} can be queried, and it can be cast to its more defined type.\par
A {\b XMLDocument} allocates memory for all its Nodes. When the {\b XMLDocument} gets deleted, all its Nodes will also be deleted.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid A Document can contain: Element (container or leaf)\par
                        Comment (leaf)\par
                        Unknown (leaf)\par
                        Declaration( leaf )\par
\par
An Element can contain: Element (container or leaf)\par
                        Text    (leaf)\par
                        Attributes (not on tree)\par
                        Comment (leaf)\par
                        Unknown (leaf)}
 \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v Accept\:tinyxml2::XMLNode}
{\xe \v tinyxml2::XMLNode\:Accept}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual bool tinyxml2::XMLNode::Accept ({\b XMLVisitor} *  {\i visitor}) const{\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAEM}
{\bkmkend AAAAAAAAEM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Accept a hierarchical visit of the nodes in the TinyXML-2 DOM. Every node in the XML tree will be conditionally visited and the host will be called back via the {\b XMLVisitor} interface.\par
This is essentially a SAX interface for TinyXML-2. (Note however it doesn't re-parse the XML for the callbacks, so the performance of TinyXML-2 is unchanged by using this interface versus any other.)\par
The interface has been based on ideas from:\par
{
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\f2 http://www.saxproject.org/}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\f2 http://c2.com/cgi/wiki?HierarchicalVisitorPattern}\par}
Which are both good references for "visiting".\par
An example of using {\b Accept()}: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid XMLPrinter printer;\par
tinyxmlDoc.Accept( &printer );\par
const char* xmlcstr = printer.CStr();\par
}
 \par
}{
Implemented in {\b tinyxml2::XMLDocument} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGK \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b tinyxml2::XMLElement} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJA \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b tinyxml2::XMLUnknown} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAALW \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b tinyxml2::XMLDeclaration} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFP \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b tinyxml2::XMLComment} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEL \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b tinyxml2::XMLText} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAALX \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v DeleteChild\:tinyxml2::XMLNode}
{\xe \v tinyxml2::XMLNode\:DeleteChild}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void tinyxml2::XMLNode::DeleteChild ({\b XMLNode} *  {\i node})}}
\par
{\bkmkstart AAAAAAAALY}
{\bkmkend AAAAAAAALY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Delete a child of this node. \par
}}
{\xe \v DeleteChildren\:tinyxml2::XMLNode}
{\xe \v tinyxml2::XMLNode\:DeleteChildren}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void tinyxml2::XMLNode::DeleteChildren ()}}
\par
{\bkmkstart AAAAAAAALZ}
{\bkmkend AAAAAAAALZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Delete all the children of this node. \par
}}
{\xe \v FirstChildElement\:tinyxml2::XMLNode}
{\xe \v tinyxml2::XMLNode\:FirstChildElement}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b XMLElement} * tinyxml2::XMLNode::FirstChildElement (const char *  {\i name} = {\f2 0}) const}}
\par
{\bkmkstart AAAAAAAAMA}
{\bkmkend AAAAAAAAMA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the first child element, or optionally the first child element with the specified name. \par
}}
{\xe \v GetUserData\:tinyxml2::XMLNode}
{\xe \v tinyxml2::XMLNode\:GetUserData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void* tinyxml2::XMLNode::GetUserData () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAMB}
{\bkmkend AAAAAAAAMB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get user data set into the {\b XMLNode}. TinyXML-2 in no way processes or interprets user data. It is initially 0. \par
}}
{\xe \v InsertAfterChild\:tinyxml2::XMLNode}
{\xe \v tinyxml2::XMLNode\:InsertAfterChild}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b XMLNode} * tinyxml2::XMLNode::InsertAfterChild ({\b XMLNode} *  {\i afterThis}, {\b XMLNode} *  {\i addThis})}}
\par
{\bkmkstart AAAAAAAAMC}
{\bkmkend AAAAAAAAMC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add a node after the specified child node. If the child node is already part of the document, it is moved from its old location to the new location. Returns the addThis argument or 0 if the afterThis node is not a child of this node, or if the node does not belong to the same document. \par
}}
{\xe \v InsertEndChild\:tinyxml2::XMLNode}
{\xe \v tinyxml2::XMLNode\:InsertEndChild}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b XMLNode} * tinyxml2::XMLNode::InsertEndChild ({\b XMLNode} *  {\i addThis})}}
\par
{\bkmkstart AAAAAAAAMD}
{\bkmkend AAAAAAAAMD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add a child node as the last (right) child. If the child node is already part of the document, it is moved from its old location to the new location. Returns the addThis argument or 0 if the node does not belong to the same document. \par
}}
{\xe \v InsertFirstChild\:tinyxml2::XMLNode}
{\xe \v tinyxml2::XMLNode\:InsertFirstChild}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b XMLNode} * tinyxml2::XMLNode::InsertFirstChild ({\b XMLNode} *  {\i addThis})}}
\par
{\bkmkstart AAAAAAAAME}
{\bkmkend AAAAAAAAME}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add a child node as the first (left) child. If the child node is already part of the document, it is moved from its old location to the new location. Returns the addThis argument or 0 if the node does not belong to the same document. \par
}}
{\xe \v LastChildElement\:tinyxml2::XMLNode}
{\xe \v tinyxml2::XMLNode\:LastChildElement}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b XMLElement} * tinyxml2::XMLNode::LastChildElement (const char *  {\i name} = {\f2 0}) const}}
\par
{\bkmkstart AAAAAAAAMF}
{\bkmkend AAAAAAAAMF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the last child element or optionally the last child element with the specified name. \par
}}
{\xe \v SetUserData\:tinyxml2::XMLNode}
{\xe \v tinyxml2::XMLNode\:SetUserData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void tinyxml2::XMLNode::SetUserData (void *  {\i userData}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAMG}
{\bkmkend AAAAAAAAMG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set user data into the {\b XMLNode}. TinyXML-2 in no way processes or interprets user data. It is initially 0. \par
}}
{\xe \v SetValue\:tinyxml2::XMLNode}
{\xe \v tinyxml2::XMLNode\:SetValue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void tinyxml2::XMLNode::SetValue (const char *  {\i val}, bool  {\i staticMem} = {\f2 false})}}
\par
{\bkmkstart AAAAAAAAMH}
{\bkmkend AAAAAAAAMH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set the Value of an XML node. \par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b Value()} \par
}}}
{\xe \v ShallowClone\:tinyxml2::XMLNode}
{\xe \v tinyxml2::XMLNode\:ShallowClone}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual {\b XMLNode}* tinyxml2::XMLNode::ShallowClone ({\b XMLDocument} *  {\i document}) const{\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAEO}
{\bkmkend AAAAAAAAEO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Make a copy of this node, but not its children. You may pass in a Document pointer that will be the owner of the new Node. If the 'document' is null, then the node returned will be allocated from the current Document. (this->{\b GetDocument()})\par
Note: if called on a {\b XMLDocument}, this will return null. \par
}{
Implemented in {\b tinyxml2::XMLDocument} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHA \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b tinyxml2::XMLElement} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJJ \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b tinyxml2::XMLUnknown} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMI \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b tinyxml2::XMLDeclaration} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFQ \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b tinyxml2::XMLComment} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEN \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b tinyxml2::XMLText} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMJ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v ShallowEqual\:tinyxml2::XMLNode}
{\xe \v tinyxml2::XMLNode\:ShallowEqual}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual bool tinyxml2::XMLNode::ShallowEqual (const {\b XMLNode} *  {\i compare}) const{\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAEQ}
{\bkmkend AAAAAAAAEQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Test if 2 nodes are the same, but don't test children. The 2 nodes do not need to be in the same Document.\par
Note: if called on a {\b XMLDocument}, this will return false. \par
}{
Implemented in {\b tinyxml2::XMLDocument} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHB \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b tinyxml2::XMLElement} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJK \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b tinyxml2::XMLUnknown} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMK \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b tinyxml2::XMLDeclaration} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFR \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b tinyxml2::XMLComment} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEP \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b tinyxml2::XMLText} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAML \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v Value\:tinyxml2::XMLNode}
{\xe \v tinyxml2::XMLNode\:Value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char * tinyxml2::XMLNode::Value () const}}
\par
{\bkmkstart AAAAAAAAMM}
{\bkmkend AAAAAAAAMM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The meaning of 'value' changes for the specific type. {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid Document:   empty (NULL is returned, not an empty string)\par
Element:    name of the element\par
Comment:    the comment text\par
Unknown:    the tag contents\par
Text:       the text string\par
}
 \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
tinyxml2.h\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
tinyxml2.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
tinyxml2::XMLPrinter Class Reference\par \pard\plain 
{\tc\tcl2 \v tinyxml2::XMLPrinter}
{\xe \v tinyxml2::XMLPrinter}
{\bkmkstart AAAAAAAAMN}
{\bkmkend AAAAAAAAMN}
\par
{
{\f2 #include <tinyxml2.h>}}\par
Inheritance diagram for tinyxml2::XMLPrinter:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classtinyxml2_1_1_x_m_l_printer.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMLPrinter} (FILE *file=0, bool compact=false, int depth=0)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b PushHeader} (bool writeBOM, bool writeDeclaration)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b OpenElement} (const char *name, bool compactMode=false)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b PushAttribute} (const char *name, const char *value){\bkmkstart AAAAAAAAMO}
{\bkmkend AAAAAAAAMO}
\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If streaming, add an attribute to an open element. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b PushAttribute} (const char *name, int value){\bkmkstart AAAAAAAAMP}
{\bkmkend AAAAAAAAMP}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b PushAttribute} (const char *name, unsigned value){\bkmkstart AAAAAAAAMQ}
{\bkmkend AAAAAAAAMQ}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b PushAttribute} (const char *name, int64_t value){\bkmkstart AAAAAAAAMR}
{\bkmkend AAAAAAAAMR}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b PushAttribute} (const char *name, bool value){\bkmkstart AAAAAAAAMS}
{\bkmkend AAAAAAAAMS}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b PushAttribute} (const char *name, double value){\bkmkstart AAAAAAAAMT}
{\bkmkend AAAAAAAAMT}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b CloseElement} (bool compactMode=false){\bkmkstart AAAAAAAAMU}
{\bkmkend AAAAAAAAMU}
\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If streaming, close the Element. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b PushText} (const char *text, bool cdata=false){\bkmkstart AAAAAAAAMV}
{\bkmkend AAAAAAAAMV}
\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add a text node. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b PushText} (int value){\bkmkstart AAAAAAAAMW}
{\bkmkend AAAAAAAAMW}
\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add a text node from an integer. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b PushText} (unsigned value){\bkmkstart AAAAAAAAMX}
{\bkmkend AAAAAAAAMX}
\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add a text node from an unsigned. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b PushText} (int64_t value){\bkmkstart AAAAAAAAMY}
{\bkmkend AAAAAAAAMY}
\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add a text node from an unsigned. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b PushText} (bool value){\bkmkstart AAAAAAAAMZ}
{\bkmkend AAAAAAAAMZ}
\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add a text node from a bool. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b PushText} (float value){\bkmkstart AAAAAAAANA}
{\bkmkend AAAAAAAANA}
\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add a text node from a float. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b PushText} (double value){\bkmkstart AAAAAAAANB}
{\bkmkend AAAAAAAANB}
\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add a text node from a double. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b PushComment} (const char *comment){\bkmkstart AAAAAAAANC}
{\bkmkend AAAAAAAANC}
\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add a comment. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b PushDeclaration} (const char *value){\bkmkstart AAAAAAAAND}
{\bkmkend AAAAAAAAND}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b PushUnknown} (const char *value){\bkmkstart AAAAAAAANE}
{\bkmkend AAAAAAAANE}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b VisitEnter} (const {\b XMLDocument} &){\bkmkstart AAAAAAAANF}
{\bkmkend AAAAAAAANF}
\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Visit a document. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b VisitExit} (const {\b XMLDocument} &){\bkmkstart AAAAAAAANG}
{\bkmkend AAAAAAAANG}
\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Visit a document. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b VisitEnter} (const {\b XMLElement} &element, const {\b XMLAttribute} *attribute){\bkmkstart AAAAAAAANH}
{\bkmkend AAAAAAAANH}
\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Visit an element. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b VisitExit} (const {\b XMLElement} &element){\bkmkstart AAAAAAAANI}
{\bkmkend AAAAAAAANI}
\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Visit an element. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b Visit} (const {\b XMLText} &text){\bkmkstart AAAAAAAANJ}
{\bkmkend AAAAAAAANJ}
\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Visit a text node. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b Visit} (const {\b XMLComment} &comment){\bkmkstart AAAAAAAANK}
{\bkmkend AAAAAAAANK}
\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Visit a comment node. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b Visit} (const {\b XMLDeclaration} &declaration){\bkmkstart AAAAAAAANL}
{\bkmkend AAAAAAAANL}
\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Visit a declaration. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b Visit} (const {\b XMLUnknown} &unknown){\bkmkstart AAAAAAAANM}
{\bkmkend AAAAAAAANM}
\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Visit an unknown node. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b CStr} () const \par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b CStrSize} () const \par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ClearBuffer} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b CompactMode} (const {\b XMLElement} &){\bkmkstart AAAAAAAANN}
{\bkmkend AAAAAAAANN}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b PrintSpace} (int depth)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b Print} (const char *format,...){\bkmkstart AAAAAAAANO}
{\bkmkend AAAAAAAANO}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b SealElementIfJustOpened} (){\bkmkstart AAAAAAAANP}
{\bkmkend AAAAAAAANP}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b _elementJustOpened}{\bkmkstart AAAAAAAANQ}
{\bkmkend AAAAAAAANQ}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b DynArray}< const char *, 10 > {\b _stack}{\bkmkstart AAAAAAAANR}
{\bkmkend AAAAAAAANR}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Printing functionality. The {\b XMLPrinter} gives you more options than the {\b XMLDocument::Print()} method.\par
It can:{
\par
\pard\plain \s90\fi-360\li360\widctlpar\fs20\cgrid 
1.\tab Print to memory.\par
\pard\plain \s90\fi-360\li360\widctlpar\fs20\cgrid 
2.\tab Print to a file you provide.\par
\pard\plain \s90\fi-360\li360\widctlpar\fs20\cgrid 
3.\tab Print XML without a {\b XMLDocument}.\par}
Print to Memory\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid XMLPrinter printer;\par
doc.Print( &printer );\par
SomeFunction( printer.CStr() );\par
}
\par
Print to a File\par
You provide the file pointer. {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid XMLPrinter printer( fp );\par
doc.Print( &printer );\par
}
\par
Print without a {\b XMLDocument}\par
When loading, an XML parser is very useful. However, sometimes when saving, it just gets in the way. The code is often set up for streaming, and constructing the DOM is just overhead.\par
The Printer supports the streaming case. The following code prints out a trivially simple XML file without ever creating an XML document.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid XMLPrinter printer( fp );\par
printer.OpenElement( "foo" );\par
printer.PushAttribute( "foo", "bar" );\par
printer.CloseElement();\par
}
 \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v XMLPrinter\:tinyxml2::XMLPrinter}
{\xe \v tinyxml2::XMLPrinter\:XMLPrinter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
tinyxml2::XMLPrinter::XMLPrinter (FILE *  {\i file} = {\f2 0}, bool  {\i compact} = {\f2 false}, int  {\i depth} = {\f2 0})}}
\par
{\bkmkstart AAAAAAAANS}
{\bkmkend AAAAAAAANS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Construct the printer. If the FILE* is specified, this will print to the FILE. Else it will print to memory, and the result is available in {\b CStr()}. If 'compact' is set to true, then output is created with only required whitespace and newlines. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v ClearBuffer\:tinyxml2::XMLPrinter}
{\xe \v tinyxml2::XMLPrinter\:ClearBuffer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void tinyxml2::XMLPrinter::ClearBuffer (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAANT}
{\bkmkend AAAAAAAANT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If in print to memory mode, reset the buffer to the beginning. \par
}}
{\xe \v CStr\:tinyxml2::XMLPrinter}
{\xe \v tinyxml2::XMLPrinter\:CStr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* tinyxml2::XMLPrinter::CStr () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAANU}
{\bkmkend AAAAAAAANU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If in print to memory mode, return a pointer to the XML file in memory. \par
}}
{\xe \v CStrSize\:tinyxml2::XMLPrinter}
{\xe \v tinyxml2::XMLPrinter\:CStrSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int tinyxml2::XMLPrinter::CStrSize () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAANV}
{\bkmkend AAAAAAAANV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If in print to memory mode, return the size of the XML file in memory. (Note the size returned includes the terminating null.) \par
}}
{\xe \v OpenElement\:tinyxml2::XMLPrinter}
{\xe \v tinyxml2::XMLPrinter\:OpenElement}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void tinyxml2::XMLPrinter::OpenElement (const char *  {\i name}, bool  {\i compactMode} = {\f2 false})}}
\par
{\bkmkstart AAAAAAAANW}
{\bkmkend AAAAAAAANW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If streaming, start writing an element. The element must be closed with {\b CloseElement()} \par
}}
{\xe \v PrintSpace\:tinyxml2::XMLPrinter}
{\xe \v tinyxml2::XMLPrinter\:PrintSpace}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void tinyxml2::XMLPrinter::PrintSpace (int  {\i depth}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAANX}
{\bkmkend AAAAAAAANX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prints out the space before an element. You may override to change the space and tabs used. A {\b PrintSpace()} override should call Print(). \par
}}
{\xe \v PushHeader\:tinyxml2::XMLPrinter}
{\xe \v tinyxml2::XMLPrinter\:PushHeader}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void tinyxml2::XMLPrinter::PushHeader (bool  {\i writeBOM}, bool  {\i writeDeclaration})}}
\par
{\bkmkstart AAAAAAAANY}
{\bkmkend AAAAAAAANY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If streaming, write the BOM and declaration. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
tinyxml2.h\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
tinyxml2.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
tinyxml2::XMLText Class Reference\par \pard\plain 
{\tc\tcl2 \v tinyxml2::XMLText}
{\xe \v tinyxml2::XMLText}
{\bkmkstart AAAAAAAANZ}
{\bkmkend AAAAAAAANZ}
\par
{
{\f2 #include <tinyxml2.h>}}\par
Inheritance diagram for tinyxml2::XMLText:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classtinyxml2_1_1_x_m_l_text.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b Accept} ({\b XMLVisitor} *visitor) const \par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual {\b XMLText} * {\b ToText} (){\bkmkstart AAAAAAAAOA}
{\bkmkend AAAAAAAAOA}
\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Safely cast to Text, or null. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const {\b XMLText} * {\b ToText} () const {\bkmkstart AAAAAAAAOB}
{\bkmkend AAAAAAAAOB}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b SetCData} (bool isCData){\bkmkstart AAAAAAAAOC}
{\bkmkend AAAAAAAAOC}
\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Declare whether this should be CDATA or standard text. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b CData} () const {\bkmkstart AAAAAAAAOD}
{\bkmkend AAAAAAAAOD}
\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if this is a CDATA text element. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b XMLNode} * {\b ShallowClone} ({\b XMLDocument} *document) const \par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b ShallowEqual} (const {\b XMLNode} *compare) const \par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b XMLText} ({\b XMLDocument} *doc){\bkmkstart AAAAAAAAOE}
{\bkmkend AAAAAAAAOE}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

char * {\b ParseDeep} (char *, {\b StrPair} *endTag){\bkmkstart AAAAAAAAOF}
{\bkmkend AAAAAAAAOF}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

class {\b XMLDocument}{\bkmkstart AAAAAAAAOG}
{\bkmkend AAAAAAAAOG}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
XML text.\par
Note that a text node can have child element nodes, for example: {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid <root>This is <b>bold</b></root>\par
}
\par
A text node can have 2 ways to output the next. "normal" output and CDATA. It will default to the mode it was parsed from the XML file and you generally want to leave it alone, but you can change the output mode with {\b SetCData()} and query it with {\b CData()}. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v Accept\:tinyxml2::XMLText}
{\xe \v tinyxml2::XMLText\:Accept}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool tinyxml2::XMLText::Accept ({\b XMLVisitor} *  {\i visitor}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAALX}
{\bkmkend AAAAAAAALX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Accept a hierarchical visit of the nodes in the TinyXML-2 DOM. Every node in the XML tree will be conditionally visited and the host will be called back via the {\b XMLVisitor} interface.\par
This is essentially a SAX interface for TinyXML-2. (Note however it doesn't re-parse the XML for the callbacks, so the performance of TinyXML-2 is unchanged by using this interface versus any other.)\par
The interface has been based on ideas from:\par
{
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\f2 http://www.saxproject.org/}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\f2 http://c2.com/cgi/wiki?HierarchicalVisitorPattern}\par}
Which are both good references for "visiting".\par
An example of using {\b Accept()}: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid XMLPrinter printer;\par
tinyxmlDoc.Accept( &printer );\par
const char* xmlcstr = printer.CStr();\par
}
 \par
}{
Implements {\b tinyxml2::XMLNode} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEM \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v ShallowClone\:tinyxml2::XMLText}
{\xe \v tinyxml2::XMLText\:ShallowClone}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b XMLNode} * tinyxml2::XMLText::ShallowClone ({\b XMLDocument} *  {\i document}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAMJ}
{\bkmkend AAAAAAAAMJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Make a copy of this node, but not its children. You may pass in a Document pointer that will be the owner of the new Node. If the 'document' is null, then the node returned will be allocated from the current Document. (this->{\b GetDocument()})\par
Note: if called on a {\b XMLDocument}, this will return null. \par
}{
Implements {\b tinyxml2::XMLNode} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEO \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v ShallowEqual\:tinyxml2::XMLText}
{\xe \v tinyxml2::XMLText\:ShallowEqual}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool tinyxml2::XMLText::ShallowEqual (const {\b XMLNode} *  {\i compare}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAML}
{\bkmkend AAAAAAAAML}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Test if 2 nodes are the same, but don't test children. The 2 nodes do not need to be in the same Document.\par
Note: if called on a {\b XMLDocument}, this will return false. \par
}{
Implements {\b tinyxml2::XMLNode} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEQ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
tinyxml2.h\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
tinyxml2.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
tinyxml2::XMLUnknown Class Reference\par \pard\plain 
{\tc\tcl2 \v tinyxml2::XMLUnknown}
{\xe \v tinyxml2::XMLUnknown}
{\bkmkstart AAAAAAAAOH}
{\bkmkend AAAAAAAAOH}
\par
{
{\f2 #include <tinyxml2.h>}}\par
Inheritance diagram for tinyxml2::XMLUnknown:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classtinyxml2_1_1_x_m_l_unknown.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual {\b XMLUnknown} * {\b ToUnknown} (){\bkmkstart AAAAAAAAOI}
{\bkmkend AAAAAAAAOI}
\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Safely cast to an Unknown, or null. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const {\b XMLUnknown} * {\b ToUnknown} () const {\bkmkstart AAAAAAAAOJ}
{\bkmkend AAAAAAAAOJ}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b Accept} ({\b XMLVisitor} *visitor) const \par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b XMLNode} * {\b ShallowClone} ({\b XMLDocument} *document) const \par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b ShallowEqual} (const {\b XMLNode} *compare) const \par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b XMLUnknown} ({\b XMLDocument} *doc){\bkmkstart AAAAAAAAOK}
{\bkmkend AAAAAAAAOK}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

char * {\b ParseDeep} (char *, {\b StrPair} *endTag){\bkmkstart AAAAAAAAOL}
{\bkmkend AAAAAAAAOL}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

class {\b XMLDocument}{\bkmkstart AAAAAAAAOM}
{\bkmkend AAAAAAAAOM}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Any tag that TinyXML-2 doesn't recognize is saved as an unknown. It is a tag of text, but should not be modified. It will be written back to the XML, unchanged, when the file is saved.\par
DTD tags get thrown into XMLUnknowns. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v Accept\:tinyxml2::XMLUnknown}
{\xe \v tinyxml2::XMLUnknown\:Accept}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool tinyxml2::XMLUnknown::Accept ({\b XMLVisitor} *  {\i visitor}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAALW}
{\bkmkend AAAAAAAALW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Accept a hierarchical visit of the nodes in the TinyXML-2 DOM. Every node in the XML tree will be conditionally visited and the host will be called back via the {\b XMLVisitor} interface.\par
This is essentially a SAX interface for TinyXML-2. (Note however it doesn't re-parse the XML for the callbacks, so the performance of TinyXML-2 is unchanged by using this interface versus any other.)\par
The interface has been based on ideas from:\par
{
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\f2 http://www.saxproject.org/}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\f2 http://c2.com/cgi/wiki?HierarchicalVisitorPattern}\par}
Which are both good references for "visiting".\par
An example of using {\b Accept()}: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid XMLPrinter printer;\par
tinyxmlDoc.Accept( &printer );\par
const char* xmlcstr = printer.CStr();\par
}
 \par
}{
Implements {\b tinyxml2::XMLNode} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEM \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v ShallowClone\:tinyxml2::XMLUnknown}
{\xe \v tinyxml2::XMLUnknown\:ShallowClone}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b XMLNode} * tinyxml2::XMLUnknown::ShallowClone ({\b XMLDocument} *  {\i document}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAMI}
{\bkmkend AAAAAAAAMI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Make a copy of this node, but not its children. You may pass in a Document pointer that will be the owner of the new Node. If the 'document' is null, then the node returned will be allocated from the current Document. (this->{\b GetDocument()})\par
Note: if called on a {\b XMLDocument}, this will return null. \par
}{
Implements {\b tinyxml2::XMLNode} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEO \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v ShallowEqual\:tinyxml2::XMLUnknown}
{\xe \v tinyxml2::XMLUnknown\:ShallowEqual}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool tinyxml2::XMLUnknown::ShallowEqual (const {\b XMLNode} *  {\i compare}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAMK}
{\bkmkend AAAAAAAAMK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Test if 2 nodes are the same, but don't test children. The 2 nodes do not need to be in the same Document.\par
Note: if called on a {\b XMLDocument}, this will return false. \par
}{
Implements {\b tinyxml2::XMLNode} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEQ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
tinyxml2.h\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
tinyxml2.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
tinyxml2::XMLUtil Class Reference\par \pard\plain 
{\tc\tcl2 \v tinyxml2::XMLUtil}
{\xe \v tinyxml2::XMLUtil}
{\bkmkstart AAAAAAAAON}
{\bkmkend AAAAAAAAON}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static const char * {\b SkipWhiteSpace} (const char *p){\bkmkstart AAAAAAAAOO}
{\bkmkend AAAAAAAAOO}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static char * {\b SkipWhiteSpace} (char *p){\bkmkstart AAAAAAAAOP}
{\bkmkend AAAAAAAAOP}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b IsWhiteSpace} (char p){\bkmkstart AAAAAAAAOQ}
{\bkmkend AAAAAAAAOQ}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b IsNameStartChar} (unsigned char ch){\bkmkstart AAAAAAAAOR}
{\bkmkend AAAAAAAAOR}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b IsNameChar} (unsigned char ch){\bkmkstart AAAAAAAAOS}
{\bkmkend AAAAAAAAOS}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b StringEqual} (const char *p, const char *q, int nChar=INT_MAX){\bkmkstart AAAAAAAAOT}
{\bkmkend AAAAAAAAOT}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b IsUTF8Continuation} (char p){\bkmkstart AAAAAAAAOU}
{\bkmkend AAAAAAAAOU}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static const char * {\b ReadBOM} (const char *p, bool *hasBOM){\bkmkstart AAAAAAAAOV}
{\bkmkend AAAAAAAAOV}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static const char * {\b GetCharacterRef} (const char *p, char *value, int *length){\bkmkstart AAAAAAAAOW}
{\bkmkend AAAAAAAAOW}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static void {\b ConvertUTF32ToUTF8} (unsigned long input, char *output, int *length){\bkmkstart AAAAAAAAOX}
{\bkmkend AAAAAAAAOX}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static void {\b ToStr} (int v, char *buffer, int bufferSize){\bkmkstart AAAAAAAAOY}
{\bkmkend AAAAAAAAOY}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static void {\b ToStr} (unsigned v, char *buffer, int bufferSize){\bkmkstart AAAAAAAAOZ}
{\bkmkend AAAAAAAAOZ}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static void {\b ToStr} (bool v, char *buffer, int bufferSize){\bkmkstart AAAAAAAAPA}
{\bkmkend AAAAAAAAPA}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static void {\b ToStr} (float v, char *buffer, int bufferSize){\bkmkstart AAAAAAAAPB}
{\bkmkend AAAAAAAAPB}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static void {\b ToStr} (double v, char *buffer, int bufferSize){\bkmkstart AAAAAAAAPC}
{\bkmkend AAAAAAAAPC}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static void {\b ToStr} (int64_t v, char *buffer, int bufferSize){\bkmkstart AAAAAAAAPD}
{\bkmkend AAAAAAAAPD}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b ToInt} (const char *str, int *value){\bkmkstart AAAAAAAAPE}
{\bkmkend AAAAAAAAPE}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b ToUnsigned} (const char *str, unsigned *value){\bkmkstart AAAAAAAAPF}
{\bkmkend AAAAAAAAPF}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b ToBool} (const char *str, bool *value){\bkmkstart AAAAAAAAPG}
{\bkmkend AAAAAAAAPG}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b ToFloat} (const char *str, float *value){\bkmkstart AAAAAAAAPH}
{\bkmkend AAAAAAAAPH}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b ToDouble} (const char *str, double *value){\bkmkstart AAAAAAAAPI}
{\bkmkend AAAAAAAAPI}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b ToInt64} (const char *str, int64_t *value){\bkmkstart AAAAAAAAPJ}
{\bkmkend AAAAAAAAPJ}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
tinyxml2.h\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
tinyxml2.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
tinyxml2::XMLVisitor Class Reference\par \pard\plain 
{\tc\tcl2 \v tinyxml2::XMLVisitor}
{\xe \v tinyxml2::XMLVisitor}
{\bkmkstart AAAAAAAAPK}
{\bkmkend AAAAAAAAPK}
\par
{
{\f2 #include <tinyxml2.h>}}\par
Inheritance diagram for tinyxml2::XMLVisitor:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classtinyxml2_1_1_x_m_l_visitor.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b VisitEnter} (const {\b XMLDocument} &){\bkmkstart AAAAAAAAPL}
{\bkmkend AAAAAAAAPL}
\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Visit a document. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b VisitExit} (const {\b XMLDocument} &){\bkmkstart AAAAAAAAPM}
{\bkmkend AAAAAAAAPM}
\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Visit a document. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b VisitEnter} (const {\b XMLElement} &, const {\b XMLAttribute} *){\bkmkstart AAAAAAAAPN}
{\bkmkend AAAAAAAAPN}
\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Visit an element. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b VisitExit} (const {\b XMLElement} &){\bkmkstart AAAAAAAAPO}
{\bkmkend AAAAAAAAPO}
\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Visit an element. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b Visit} (const {\b XMLDeclaration} &){\bkmkstart AAAAAAAAPP}
{\bkmkend AAAAAAAAPP}
\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Visit a declaration. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b Visit} (const {\b XMLText} &){\bkmkstart AAAAAAAAPQ}
{\bkmkend AAAAAAAAPQ}
\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Visit a text node. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b Visit} (const {\b XMLComment} &){\bkmkstart AAAAAAAAPR}
{\bkmkend AAAAAAAAPR}
\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Visit a comment node. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b Visit} (const {\b XMLUnknown} &){\bkmkstart AAAAAAAAPS}
{\bkmkend AAAAAAAAPS}
\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Visit an unknown node. }{
}\par
}}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Implements the interface to the "Visitor pattern" (see the Accept() method.) If you call the Accept() method, it requires being passed a {\b XMLVisitor} class to handle callbacks. For nodes that contain other nodes (Document, Element) you will get called with a VisitEnter/VisitExit pair. Nodes that are always leafs are simply called with {\b Visit()}.\par
If you return 'true' from a Visit method, recursive parsing will continue. If you return false, {\b no children of this node or its siblings}  will be visited.\par
All flavors of Visit methods have a default implementation that returns 'true' (continue visiting). You need to only override methods that are interesting to you.\par
Generally Accept() is called on the {\b XMLDocument}, although all nodes support visiting.\par
You should never change the document from a callback.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid {\b XMLNode::Accept()} \par
}}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
tinyxml2.h\par
}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Index\par 
\pard\plain 
{\tc \v Index}
{\field\fldedit {\*\fldinst INDEX \\c2 \\*MERGEFORMAT}{\fldrslt INDEX}}
}